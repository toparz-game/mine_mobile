<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase3-3: çµæœçµ±åˆå‡¦ç†ã®ãƒ“ãƒƒãƒˆåŒ–ãƒ†ã‚¹ãƒˆ</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }
        .test-section {
            background-color: #2d2d2d;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .success { color: #4CAF50; }
        .error { color: #f44336; }
        .warning { color: #ff9800; }
        .info { color: #2196F3; }
        .test-button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: all 0.3s;
        }
        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }
        .test-results {
            background-color: #1e1e1e;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            max-height: 400px;
            overflow-y: auto;
        }
        .performance-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .metric-card {
            background-color: #333;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }
        .metric-label {
            font-size: 14px;
            color: #bbb;
            margin-top: 5px;
        }
        .integration-demo {
            background-color: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”— Phase3-3: çµæœçµ±åˆå‡¦ç†ã®ãƒ“ãƒƒãƒˆåŒ–</h1>
            <p>ç›®æ¨™: è¤‡æ•°ã‚°ãƒ«ãƒ¼ãƒ—ã®è§£æ±ºçµæœçµ±åˆã‚’ãƒ“ãƒƒãƒˆåŒ–ã«ã‚ˆã‚‹é«˜é€Ÿå‡¦ç†</p>
            <p>çµ±åˆãƒ¡ã‚½ãƒƒãƒ‰: integrateMultiGroupSolutionsBit, mergeConstraintSolutionsBit, validateIntegratedSolutionBit</p>
        </div>

        <div class="test-section">
            <h2>ğŸ“‹ Phase3-3 æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</h2>
            <button class="test-button" onclick="testIntegrateMultiGroupSolutions()">1. integrateMultiGroupSolutionsBit() ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testMergeConstraintSolutions()">2. mergeConstraintSolutionsBit() ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testValidateIntegratedSolution()">3. validateIntegratedSolutionBit() ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="runAllTests()">ğŸ¯ å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
            <button class="test-button" onclick="clearResults()" style="background: linear-gradient(45deg, #f44336, #d32f2f);">ğŸ§¹ çµæœã‚¯ãƒªã‚¢</button>
            <div id="testResults" class="test-results"></div>
        </div>

        <div class="test-section">
            <h2>âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š</h2>
            <button class="test-button" onclick="benchmarkIntegrationPerformance()">çµ±åˆå‡¦ç†æ€§èƒ½ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯</button>
            <button class="test-button" onclick="benchmarkLargeGroupIntegration()">å¤§è¦æ¨¡ã‚°ãƒ«ãƒ¼ãƒ—çµ±åˆãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯</button>
            <button class="test-button" onclick="benchmarkConflictResolution()">ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆè§£æ±ºãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯</button>
            <button class="test-button" onclick="benchmarkValidationPerformance()">æ¤œè¨¼å‡¦ç†æ€§èƒ½ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯</button>
            <div id="performanceResults" class="test-results"></div>
            <div id="performanceMetrics" class="performance-metrics"></div>
        </div>

        <div class="test-section">
            <h2>ğŸ” è©³ç´°å‹•ä½œãƒ†ã‚¹ãƒˆ</h2>
            <button class="test-button" onclick="testComplexIntegrationScenarios()">è¤‡é›‘çµ±åˆã‚·ãƒŠãƒªã‚ªãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testConflictDetection()">ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆæ¤œå‡ºç²¾åº¦ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testEdgeCases()">ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testIntegrationDemo()">ğŸª çµ±åˆå‡¦ç†ãƒ‡ãƒ¢</button>
            <div id="detailedResults" class="test-results"></div>
        </div>

        <div class="test-section">
            <h2>ğŸ“Š çµ±åˆçµæœè¡¨ç¤º</h2>
            <div id="integrationDemo" class="integration-demo"></div>
        </div>
    </div>

    <script src="modules/bit-minesweeper.js"></script>
    <script src="modules/simple-bit-csp.js"></script>
    <script>
        let testResults, performanceResults, detailedResults, performanceMetrics, integrationDemo;
        let mockGame, bitSystem, bitCSP;

        // DOMãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã‹ã‚‰åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', function() {
            testResults = document.getElementById('testResults');
            performanceResults = document.getElementById('performanceResults');
            detailedResults = document.getElementById('detailedResults');
            performanceMetrics = document.getElementById('performanceMetrics');
            integrationDemo = document.getElementById('integrationDemo');

            // ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ¢ãƒƒã‚¯ã‚²ãƒ¼ãƒ ç’°å¢ƒ
            mockGame = {
                rows: 16,
                cols: 16,
                mines: 40,
                board: Array(16).fill().map(() => Array(16).fill(0)),
                isValidCoord: (row, col) => row >= 0 && row < 16 && col >= 0 && col < 16
            };

            // BitMinesweeperSystemã¨SimpleBitCSPã‚’åˆæœŸåŒ–
            try {
                bitSystem = new BitMinesweeperSystem(mockGame);
                bitCSP = new SimpleBitCSP(mockGame, bitSystem);
                log("ğŸš€ Phase3-3ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†", testResults, 'success');
                log("çµæœçµ±åˆå‡¦ç†ã®ãƒ“ãƒƒãƒˆåŒ–æ©Ÿèƒ½ã‚’ãƒ†ã‚¹ãƒˆã—ã¾ã™", testResults, 'info');
            } catch (error) {
                console.error('åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                if (testResults) {
                    log(`âŒ åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, testResults, 'error');
                }
            }
        });

        function log(message, element = testResults, className = '') {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}\n`;
            element.textContent += logMessage;
            if (className) {
                element.className += ` ${className}`;
            }
            element.scrollTop = element.scrollHeight;
        }

        function clearResults() {
            testResults.textContent = '';
            performanceResults.textContent = '';
            detailedResults.textContent = '';
            performanceMetrics.innerHTML = '';
            integrationDemo.innerHTML = '';
        }

        // ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ¢ãƒƒã‚¯ã‚°ãƒ«ãƒ¼ãƒ—è§£æ±ºçµæœã‚’ç”Ÿæˆ
        function createMockGroupSolutions(count = 3, conflictEnabled = true) {
            const groupSolutions = [];
            
            for (let i = 0; i < count; i++) {
                const cellCount = 4 + i;
                const cells = Array(cellCount).fill().map((_, j) => ({
                    row: Math.floor((i * 2 + j) / 4),
                    col: (i * 2 + j) % 4
                }));
                
                // æ„å›³çš„ã«é‡è¤‡ã‚»ãƒ«ã‚’ä½œæˆï¼ˆã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãƒ†ã‚¹ãƒˆç”¨ï¼‰
                if (conflictEnabled && i > 0) {
                    cells[0] = { row: 0, col: i - 1 }; // å‰ã®ã‚°ãƒ«ãƒ¼ãƒ—ã¨é‡è¤‡
                }
                
                const cellProbabilities = {};
                for (const cell of cells) {
                    const cellKey = `${cell.row},${cell.col}`;
                    cellProbabilities[cellKey] = Math.random() * 0.6 + 0.2; // 0.2-0.8ã®ç¯„å›²
                }
                
                groupSolutions.push({
                    success: true,
                    groupId: i,
                    cells: cells,
                    solutionCount: Math.floor(Math.random() * 20) + 5,
                    executionTime: Math.random() * 2 + 0.5,
                    cellProbabilities: cellProbabilities
                });
            }
            
            return groupSolutions;
        }

        // 1. integrateMultiGroupSolutionsBit() ãƒ†ã‚¹ãƒˆ
        function testIntegrateMultiGroupSolutions() {
            log("=== integrateMultiGroupSolutionsBit() ãƒ†ã‚¹ãƒˆé–‹å§‹ ===", testResults, 'info');
            
            // bitCSPãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if (!bitCSP) {
                log("âŒ bitCSP ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚", testResults, 'error');
                return false;
            }
            
            try {
                // ãƒ†ã‚¹ãƒˆ1: åŸºæœ¬çš„ãªçµ±åˆå‡¦ç†
                const mockGroups = createMockGroupSolutions(3, false);
                const result1 = bitCSP.integrateMultiGroupSolutionsBit(mockGroups);
                
                log(`${result1.success ? 'âœ…' : 'âŒ'} åŸºæœ¬çµ±åˆãƒ†ã‚¹ãƒˆ: ${result1.success ? 'æˆåŠŸ' : 'å¤±æ•—'}`, testResults, 
                    result1.success ? 'success' : 'error');
                
                if (result1.success) {
                    log(`   - çµ±åˆã‚°ãƒ«ãƒ¼ãƒ—æ•°: ${result1.integration.totalGroups}`, testResults);
                    log(`   - ç·ã‚»ãƒ«æ•°: ${result1.totalCells}`, testResults);
                    log(`   - ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆæ•°: ${result1.conflictCount}`, testResults);
                    log(`   - å®Ÿè¡Œæ™‚é–“: ${result1.executionTime.toFixed(4)}ms`, testResults);
                    log(`   - çµ±åˆç¢ºç‡ã‚¨ãƒ³ãƒˆãƒªæ•°: ${Object.keys(result1.integration.combinedProbabilities).length}`, testResults);
                } else {
                    log(`   - å¤±æ•—ç†ç”±: ${result1.reason}`, testResults, 'error');
                    log(`   - ã‚¨ãƒ©ãƒ¼: ${result1.error || 'N/A'}`, testResults, 'error');
                }
                
                if (!result1.success) {
                    log("âŒ integrateMultiGroupSolutionsBit() ãƒ†ã‚¹ãƒˆå¤±æ•—", testResults, 'error');
                    return false;
                }

                // ãƒ†ã‚¹ãƒˆ2: ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆä»˜ãçµ±åˆ
                const conflictGroups = createMockGroupSolutions(4, true);
                const result2 = bitCSP.integrateMultiGroupSolutionsBit(conflictGroups);
                
                log(`${result2.success ? 'âœ…' : 'âŒ'} ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆçµ±åˆãƒ†ã‚¹ãƒˆ: ${result2.success ? 'æˆåŠŸ' : 'å¤±æ•—'}`, testResults, 
                    result2.success ? 'success' : 'error');
                
                if (result2.success) {
                    log(`   - ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆæ¤œå‡º: ${result2.hasConflicts ? 'ã‚ã‚Š' : 'ãªã—'} (${result2.conflictCount}å€‹)`, testResults);
                    log(`   - çµ±åˆã•ã‚ŒãŸã‚»ãƒ«æ•°: ${result2.totalCells}`, testResults);
                    
                    // ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆã®è©³ç´°è¡¨ç¤º
                    if (result2.integration.conflicts.length > 0) {
                        log(`   - ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆè©³ç´°:`, testResults, 'warning');
                        for (const conflict of result2.integration.conflicts.slice(0, 3)) {
                            log(`     ${conflict.cell}: ã‚°ãƒ«ãƒ¼ãƒ—${conflict.groups[0]} vs ã‚°ãƒ«ãƒ¼ãƒ—${conflict.groups[1]}`, testResults);
                        }
                    }
                } else {
                    log(`   - å¤±æ•—ç†ç”±: ${result2.reason}`, testResults, 'error');
                }
                
                if (!result2.success) {
                    log("âŒ integrateMultiGroupSolutionsBit() ãƒ†ã‚¹ãƒˆå¤±æ•—", testResults, 'error');
                    return false;
                }

                // ãƒ†ã‚¹ãƒˆ3: ç©ºã‚°ãƒ«ãƒ¼ãƒ—ã®å‡¦ç†
                const emptyResult = bitCSP.integrateMultiGroupSolutionsBit([]);
                log(`âœ… ç©ºã‚°ãƒ«ãƒ¼ãƒ—ãƒ†ã‚¹ãƒˆ: ${!emptyResult.success ? 'æ­£å¸¸æ‹’å¦' : 'ã‚¨ãƒ©ãƒ¼'}`, testResults,
                    !emptyResult.success ? 'success' : 'error');

                // ãƒ†ã‚¹ãƒˆ4: å¤§è¦æ¨¡ã‚°ãƒ«ãƒ¼ãƒ—çµ±åˆ
                const largeGroups = createMockGroupSolutions(10, false);
                const largeResult = bitCSP.integrateMultiGroupSolutionsBit(largeGroups);
                
                log(`${largeResult.success ? 'âœ…' : 'âŒ'} å¤§è¦æ¨¡çµ±åˆãƒ†ã‚¹ãƒˆ: ${largeResult.success ? 'æˆåŠŸ' : 'å¤±æ•—'} (10ã‚°ãƒ«ãƒ¼ãƒ—)`, testResults,
                    largeResult.success ? 'success' : 'error');
                
                if (largeResult.success) {
                    log(`   - å‡¦ç†æ™‚é–“: ${largeResult.executionTime.toFixed(4)}ms`, testResults);
                    log(`   - çµ±åˆåŠ¹ç‡: ${(largeResult.totalCells / largeResult.integration.totalGroups).toFixed(1)}ã‚»ãƒ«/ã‚°ãƒ«ãƒ¼ãƒ—`, testResults);
                } else {
                    log(`   - å¤±æ•—ç†ç”±: ${largeResult.reason}`, testResults, 'error');
                }
                
                if (!largeResult.success) {
                    log("âŒ integrateMultiGroupSolutionsBit() ãƒ†ã‚¹ãƒˆå¤±æ•—", testResults, 'error');
                    return false;
                }

                log("âœ… integrateMultiGroupSolutionsBit() å…¨ãƒ†ã‚¹ãƒˆæˆåŠŸ", testResults, 'success');
                return true;

            } catch (error) {
                log(`âŒ integrateMultiGroupSolutionsBit() ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, testResults, 'error');
                return false;
            }
        }

        // 2. mergeConstraintSolutionsBit() ãƒ†ã‚¹ãƒˆ
        function testMergeConstraintSolutions() {
            log("=== mergeConstraintSolutionsBit() ãƒ†ã‚¹ãƒˆé–‹å§‹ ===", testResults, 'info');
            
            // bitCSPãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if (!bitCSP) {
                log("âŒ bitCSP ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚", testResults, 'error');
                return false;
            }
            
            try {
                // ãƒ†ã‚¹ãƒˆç”¨ã®åˆ¶ç´„è§£æ±ºçµæœã‚’ç”Ÿæˆ
                const createMockSolutions = (count) => {
                    const solutions = [];
                    for (let i = 0; i < count; i++) {
                        const cellProbabilities = {};
                        for (let j = 0; j < 3; j++) {
                            cellProbabilities[`${i},${j}`] = Math.random() * 0.4 + 0.3; // 0.3-0.7ã®ç¯„å›²
                        }
                        
                        solutions.push({
                            success: true,
                            solutionId: i,
                            cellProbabilities: cellProbabilities,
                            solutionCount: Math.floor(Math.random() * 15) + 5
                        });
                    }
                    return solutions;
                };

                // ãƒ†ã‚¹ãƒˆ1: åŸºæœ¬çš„ãªãƒãƒ¼ã‚¸å‡¦ç†
                const mockSolutions = createMockSolutions(5);
                const result1 = bitCSP.mergeConstraintSolutionsBit(mockSolutions);
                
                log(`âœ… åŸºæœ¬ãƒãƒ¼ã‚¸ãƒ†ã‚¹ãƒˆ: ${result1.success ? 'æˆåŠŸ' : 'å¤±æ•—'}`, testResults,
                    result1.success ? 'success' : 'error');
                
                if (result1.success) {
                    log(`   - ãƒãƒ¼ã‚¸è§£æ±ºæ•°: ${result1.merge.mergedCount}/${result1.merge.totalSolutionSets}`, testResults);
                    log(`   - ç·ã‚»ãƒ«æ•°: ${result1.totalCells}`, testResults);
                    log(`   - å…±é€šã‚»ãƒ«æ•°: ${result1.commonCells}`, testResults);
                    log(`   - ä¸€è²«æ€§: ${result1.consistency ? 'ã‚ã‚Š' : 'ãªã—'}`, testResults);
                    log(`   - ãƒãƒ¼ã‚¸æ¯”ç‡: ${(result1.mergeRatio * 100).toFixed(1)}%`, testResults);
                    log(`   - å®Ÿè¡Œæ™‚é–“: ${result1.executionTime.toFixed(4)}ms`, testResults);
                }

                // ãƒ†ã‚¹ãƒˆ2: ä¸€è²«æ€§ã®ç„¡ã„è§£æ±ºã‚»ãƒƒãƒˆã®ãƒãƒ¼ã‚¸
                const inconsistentSolutions = createMockSolutions(3);
                // æ„å›³çš„ã«å¤§ããç•°ãªã‚‹ç¢ºç‡ã‚’è¨­å®š
                inconsistentSolutions[1].cellProbabilities["0,0"] = 0.9; // ä»–ã¯0.3-0.7ç¯„å›²
                
                const result2 = bitCSP.mergeConstraintSolutionsBit(inconsistentSolutions);
                log(`âœ… ä¸€è²«æ€§ãƒã‚§ãƒƒã‚¯ãƒ†ã‚¹ãƒˆ: ä¸€è²«æ€§${result2.consistency ? 'ã‚ã‚Š' : 'ãªã—'}`, testResults,
                    result2.consistency ? 'warning' : 'success');

                // ãƒ†ã‚¹ãƒˆ3: å¤§è¦æ¨¡ãƒãƒ¼ã‚¸å‡¦ç†
                const largeSolutions = createMockSolutions(50);
                const largeResult = bitCSP.mergeConstraintSolutionsBit(largeSolutions);
                
                log(`âœ… å¤§è¦æ¨¡ãƒãƒ¼ã‚¸ãƒ†ã‚¹ãƒˆ: ${largeResult.success ? 'æˆåŠŸ' : 'å¤±æ•—'} (50ã‚»ãƒƒãƒˆ)`, testResults,
                    largeResult.success ? 'success' : 'error');
                
                if (largeResult.success) {
                    log(`   - å‡¦ç†æ™‚é–“: ${largeResult.executionTime.toFixed(4)}ms`, testResults);
                    log(`   - ãƒãƒ¼ã‚¸ã•ã‚ŒãŸã‚»ãƒƒãƒˆæ•°: ${largeResult.merge.mergedCount}`, testResults);
                }

                // ãƒ†ã‚¹ãƒˆ4: ç©ºè§£æ±ºã‚»ãƒƒãƒˆã®å‡¦ç†
                const emptyResult = bitCSP.mergeConstraintSolutionsBit([]);
                log(`âœ… ç©ºã‚»ãƒƒãƒˆãƒ†ã‚¹ãƒˆ: ${!emptyResult.success ? 'æ­£å¸¸æ‹’å¦' : 'ã‚¨ãƒ©ãƒ¼'}`, testResults,
                    !emptyResult.success ? 'success' : 'error');

                log("âœ… mergeConstraintSolutionsBit() å…¨ãƒ†ã‚¹ãƒˆæˆåŠŸ", testResults, 'success');
                return true;

            } catch (error) {
                log(`âŒ mergeConstraintSolutionsBit() ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, testResults, 'error');
                return false;
            }
        }

        // 3. validateIntegratedSolutionBit() ãƒ†ã‚¹ãƒˆ
        function testValidateIntegratedSolution() {
            log("=== validateIntegratedSolutionBit() ãƒ†ã‚¹ãƒˆé–‹å§‹ ===", testResults, 'info');
            
            // bitCSPãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if (!bitCSP) {
                log("âŒ bitCSP ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚", testResults, 'error');
                return false;
            }
            
            try {
                // ãƒ†ã‚¹ãƒˆ1: æ­£å¸¸ãªçµ±åˆè§£æ±ºã®æ¤œè¨¼
                const validIntegratedSolution = {
                    success: true,
                    integration: {
                        totalGroups: 3,
                        combinedProbabilities: {
                            "0,0": { probability: 0.5, confidence: 1.0, sources: 1 },
                            "0,1": { probability: 0.7, confidence: 0.9, sources: 2 },
                            "1,0": { probability: 0.3, confidence: 1.0, sources: 1 }
                        },
                        conflicts: []
                    },
                    hasConflicts: false,
                    conflictCount: 0
                };
                
                const result1 = bitCSP.validateIntegratedSolutionBit(validIntegratedSolution);
                
                log(`âœ… æ­£å¸¸è§£æ±ºæ¤œè¨¼ãƒ†ã‚¹ãƒˆ: ${result1.success ? 'æˆåŠŸ' : 'å¤±æ•—'}`, testResults,
                    result1.success ? 'success' : 'error');
                
                if (result1.success) {
                    log(`   - å¦¥å½“æ€§: ${result1.valid ? 'å¦¥å½“' : 'ç„¡åŠ¹'}`, testResults, result1.valid ? 'success' : 'error');
                    log(`   - ã‚¨ãƒ©ãƒ¼æ•°: ${result1.summary.totalErrors}`, testResults);
                    log(`   - è­¦å‘Šæ•°: ${result1.summary.totalWarnings}`, testResults);
                    log(`   - æ¤œè¨¼ã‚»ãƒ«æ•°: ${result1.summary.totalCells}`, testResults);
                    log(`   - å¹³å‡ç¢ºç‡: ${result1.summary.averageProbability}`, testResults);
                    log(`   - å®Ÿè¡Œæ™‚é–“: ${result1.executionTime.toFixed(4)}ms`, testResults);
                }

                // ãƒ†ã‚¹ãƒˆ2: ç„¡åŠ¹ãªç¢ºç‡ã‚’å«ã‚€è§£æ±ºã®æ¤œè¨¼
                const invalidProbabilitySolution = {
                    integration: {
                        combinedProbabilities: {
                            "0,0": { probability: 1.5, confidence: 1.0 }, // ç„¡åŠ¹ãªç¢ºç‡
                            "0,1": { probability: -0.2, confidence: 1.0 }, // ç„¡åŠ¹ãªç¢ºç‡
                            "invalid_coord": { probability: 0.5, confidence: 1.0 } // ç„¡åŠ¹ãªåº§æ¨™
                        }
                    }
                };
                
                const result2 = bitCSP.validateIntegratedSolutionBit(invalidProbabilitySolution);
                log(`âœ… ç„¡åŠ¹ç¢ºç‡æ¤œè¨¼ãƒ†ã‚¹ãƒˆ: å¦¥å½“æ€§${result2.valid ? 'ã‚ã‚Šï¼ˆã‚¨ãƒ©ãƒ¼ï¼‰' : 'ãªã—'}`, testResults,
                    result2.valid ? 'error' : 'success');
                
                if (result2.success) {
                    log(`   - æ¤œå‡ºã‚¨ãƒ©ãƒ¼æ•°: ${result2.summary.totalErrors}`, testResults);
                    log(`   - ä¸»è¦ã‚¨ãƒ©ãƒ¼ä¾‹: ${result2.validation.errors[0]}`, testResults, 'warning');
                }

                // ãƒ†ã‚¹ãƒˆ3: ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆä»˜ãè§£æ±ºã®æ¤œè¨¼
                const conflictSolution = {
                    integration: {
                        combinedProbabilities: {
                            "0,0": { probability: 0.6, confidence: 0.7, sources: 3, variance: 0.3 }
                        },
                        conflicts: [{ cell: "0,0", groups: [0, 1], type: "overlap" }]
                    },
                    hasConflicts: true,
                    conflictCount: 1
                };
                
                const result3 = bitCSP.validateIntegratedSolutionBit(conflictSolution);
                log(`âœ… ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆæ¤œè¨¼ãƒ†ã‚¹ãƒˆ: è­¦å‘Šæ•°${result3.success ? result3.summary.totalWarnings : 0}å€‹`, testResults,
                    result3.success && result3.summary.totalWarnings > 0 ? 'success' : 'error');

                // ãƒ†ã‚¹ãƒˆ4: ç©ºè§£æ±ºã®æ¤œè¨¼
                const emptyResult = bitCSP.validateIntegratedSolutionBit(null);
                log(`âœ… nullè§£æ±ºæ¤œè¨¼ãƒ†ã‚¹ãƒˆ: ${!emptyResult.success ? 'æ­£å¸¸æ‹’å¦' : 'ã‚¨ãƒ©ãƒ¼'}`, testResults,
                    !emptyResult.success ? 'success' : 'error');

                // ãƒ†ã‚¹ãƒˆ5: ãƒãƒ¼ã‚¸è§£æ±ºã®æ¤œè¨¼
                const mergeResult = bitCSP.mergeConstraintSolutionsBit([
                    { success: true, cellProbabilities: { "0,0": 0.4, "0,1": 0.6 } },
                    { success: true, cellProbabilities: { "0,0": 0.5, "0,1": 0.7 } }
                ]);
                
                if (mergeResult.success) {
                    const mergeValidation = bitCSP.validateIntegratedSolutionBit(mergeResult);
                    log(`âœ… ãƒãƒ¼ã‚¸è§£æ±ºæ¤œè¨¼ãƒ†ã‚¹ãƒˆ: ${mergeValidation.valid ? 'å¦¥å½“' : 'ç„¡åŠ¹'}`, testResults,
                        mergeValidation.valid ? 'success' : 'warning');
                }

                log("âœ… validateIntegratedSolutionBit() å…¨ãƒ†ã‚¹ãƒˆæˆåŠŸ", testResults, 'success');
                return true;

            } catch (error) {
                log(`âŒ validateIntegratedSolutionBit() ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, testResults, 'error');
                return false;
            }
        }

        // å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
        function runAllTests() {
            log("ğŸš€ Phase3-3 å…¨æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆé–‹å§‹", testResults, 'info');
            log("=" * 60, testResults);
            
            let allPassed = true;
            const tests = [
                { name: "integrateMultiGroupSolutionsBit()", func: testIntegrateMultiGroupSolutions },
                { name: "mergeConstraintSolutionsBit()", func: testMergeConstraintSolutions },
                { name: "validateIntegratedSolutionBit()", func: testValidateIntegratedSolution }
            ];

            for (const test of tests) {
                log(`\n--- ${test.name} ãƒ†ã‚¹ãƒˆ ---`, testResults, 'info');
                const passed = test.func();
                allPassed = allPassed && passed;
                log(`${test.name}: ${passed ? 'âœ… æˆåŠŸ' : 'âŒ å¤±æ•—'}`, testResults, passed ? 'success' : 'error');
            }

            log("\n" + "=" * 60, testResults);
            log(`ğŸ¯ Phase3-3 å…¨ãƒ†ã‚¹ãƒˆçµæœ: ${allPassed ? 'âœ… å…¨ã¦æˆåŠŸ' : 'âŒ ä¸€éƒ¨å¤±æ•—'}`, testResults, 
                allPassed ? 'success' : 'error');
        }

        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆé–¢æ•°ç¾¤
        function benchmarkIntegrationPerformance() {
            log("âš¡ çµ±åˆå‡¦ç†æ€§èƒ½ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–‹å§‹", performanceResults, 'info');
            
            const results = [];
            for (let groupCount = 2; groupCount <= 20; groupCount += 2) {
                const mockGroups = createMockGroupSolutions(groupCount, false);
                
                const startTime = performance.now();
                const result = bitCSP.integrateMultiGroupSolutionsBit(mockGroups);
                const endTime = performance.now();
                
                const executionTime = endTime - startTime;
                results.push({
                    groupCount: groupCount,
                    executionTime: executionTime,
                    totalCells: result.success ? result.totalCells : 0,
                    success: result.success
                });
                
                log(`${groupCount}ã‚°ãƒ«ãƒ¼ãƒ—: ${executionTime.toFixed(4)}ms (${result.success ? result.totalCells + 'ã‚»ãƒ«' : 'å¤±æ•—'})`,
                    performanceResults, result.success ? 'success' : 'error');
            }
            
            // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆ
            const avgTime = results.filter(r => r.success).reduce((sum, r) => sum + r.executionTime, 0) / 
                           results.filter(r => r.success).length;
            const maxTime = Math.max(...results.filter(r => r.success).map(r => r.executionTime));
            
            updatePerformanceMetrics({
                'avg_integration_time': { value: avgTime.toFixed(4) + 'ms', label: 'å¹³å‡çµ±åˆæ™‚é–“' },
                'max_integration_time': { value: maxTime.toFixed(4) + 'ms', label: 'æœ€å¤§çµ±åˆæ™‚é–“' },
                'success_rate': { value: (results.filter(r => r.success).length / results.length * 100).toFixed(1) + '%', label: 'æˆåŠŸç‡' },
                'max_groups_tested': { value: results.length.toString(), label: 'æœ€å¤§ãƒ†ã‚¹ãƒˆã‚°ãƒ«ãƒ¼ãƒ—æ•°' }
            });
        }

        function benchmarkLargeGroupIntegration() {
            log("âš¡ å¤§è¦æ¨¡ã‚°ãƒ«ãƒ¼ãƒ—çµ±åˆãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–‹å§‹", performanceResults, 'info');
            log("å®Ÿè£…äºˆå®š: 50-100ã‚°ãƒ«ãƒ¼ãƒ—è¦æ¨¡ã§ã®çµ±åˆæ€§èƒ½æ¸¬å®š", performanceResults, 'warning');
        }

        function benchmarkConflictResolution() {
            log("âš¡ ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆè§£æ±ºãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–‹å§‹", performanceResults, 'info');
            log("å®Ÿè£…äºˆå®š: æ§˜ã€…ãªã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã®è§£æ±ºæ€§èƒ½æ¸¬å®š", performanceResults, 'warning');
        }

        function benchmarkValidationPerformance() {
            log("âš¡ æ¤œè¨¼å‡¦ç†æ€§èƒ½ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–‹å§‹", performanceResults, 'info');
            log("å®Ÿè£…äºˆå®š: å¤§è¦æ¨¡çµ±åˆè§£æ±ºã®æ¤œè¨¼å‡¦ç†æ€§èƒ½æ¸¬å®š", performanceResults, 'warning');
        }

        // è©³ç´°ãƒ†ã‚¹ãƒˆé–¢æ•°ç¾¤
        function testComplexIntegrationScenarios() {
            log("ğŸ” è¤‡é›‘çµ±åˆã‚·ãƒŠãƒªã‚ªãƒ†ã‚¹ãƒˆé–‹å§‹", detailedResults, 'info');
            log("å®Ÿè£…äºˆå®š: è¤‡é›‘ãªé‡è¤‡ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆè§£æ±ºã‚·ãƒŠãƒªã‚ª", detailedResults, 'warning');
        }

        function testConflictDetection() {
            log("ğŸ” ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆæ¤œå‡ºç²¾åº¦ãƒ†ã‚¹ãƒˆé–‹å§‹", detailedResults, 'info');
            log("å®Ÿè£…äºˆå®š: å¾®ç´°ãªã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡ºç²¾åº¦ãƒ†ã‚¹ãƒˆ", detailedResults, 'warning');
        }

        function testEdgeCases() {
            log("ğŸ” ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹", detailedResults, 'info');
            log("å®Ÿè£…äºˆå®š: æ¥µç«¯ãªæ¡ä»¶ã§ã®çµ±åˆå‡¦ç†ãƒ†ã‚¹ãƒˆ", detailedResults, 'warning');
        }

        // çµ±åˆå‡¦ç†ãƒ‡ãƒ¢
        function testIntegrationDemo() {
            log("ğŸª çµ±åˆå‡¦ç†ãƒ‡ãƒ¢é–‹å§‹", detailedResults, 'info');
            
            // ãƒ‡ãƒ¢ç”¨ã®ã‚°ãƒ«ãƒ¼ãƒ—è§£æ±ºçµæœã‚’ä½œæˆ
            const demoGroups = [
                {
                    success: true,
                    groupId: "A",
                    cells: [{row: 0, col: 0}, {row: 0, col: 1}],
                    cellProbabilities: {"0,0": 0.3, "0,1": 0.7},
                    solutionCount: 8
                },
                {
                    success: true,
                    groupId: "B", 
                    cells: [{row: 0, col: 1}, {row: 1, col: 1}],
                    cellProbabilities: {"0,1": 0.6, "1,1": 0.4},
                    solutionCount: 12
                },
                {
                    success: true,
                    groupId: "C",
                    cells: [{row: 1, col: 0}, {row: 1, col: 1}],
                    cellProbabilities: {"1,0": 0.8, "1,1": 0.5},
                    solutionCount: 6
                }
            ];
            
            // çµ±åˆå‡¦ç†å®Ÿè¡Œ
            const integrationResult = bitCSP.integrateMultiGroupSolutionsBit(demoGroups);
            
            if (integrationResult.success) {
                // ãƒ‡ãƒ¢çµæœã®å¯è¦–åŒ–
                let demoHTML = '<h3>ğŸ“Š çµ±åˆå‡¦ç†ãƒ‡ãƒ¢çµæœ</h3>';
                demoHTML += `<p><strong>çµ±åˆã‚°ãƒ«ãƒ¼ãƒ—æ•°:</strong> ${integrationResult.integration.totalGroups}</p>`;
                demoHTML += `<p><strong>ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆæ•°:</strong> ${integrationResult.conflictCount}</p>`;
                demoHTML += `<p><strong>çµ±åˆå¾Œã‚»ãƒ«ç¢ºç‡:</strong></p>`;
                demoHTML += '<ul>';
                
                for (const [cellKey, probData] of Object.entries(integrationResult.integration.combinedProbabilities)) {
                    const prob = typeof probData === 'object' ? probData.probability : probData;
                    const sources = typeof probData === 'object' ? probData.sources : 1;
                    const integrated = typeof probData === 'object' ? probData.integrated : false;
                    
                    demoHTML += `<li>ã‚»ãƒ«(${cellKey}): ${(prob * 100).toFixed(1)}% 
                                ${integrated ? `[çµ±åˆ: ${sources}ã‚½ãƒ¼ã‚¹]` : '[å˜ç‹¬]'}</li>`;
                }
                
                demoHTML += '</ul>';
                
                if (integrationResult.integration.conflicts.length > 0) {
                    demoHTML += '<p><strong>ğŸš¨ æ¤œå‡ºã•ã‚ŒãŸã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆ:</strong></p><ul>';
                    for (const conflict of integrationResult.integration.conflicts) {
                        demoHTML += `<li>ã‚»ãƒ«(${conflict.cell}): ã‚°ãƒ«ãƒ¼ãƒ—${conflict.groups.join(' vs ')}</li>`;
                    }
                    demoHTML += '</ul>';
                }
                
                integrationDemo.innerHTML = demoHTML;
                
                log("âœ… çµ±åˆå‡¦ç†ãƒ‡ãƒ¢å®Œäº† - çµæœã¯ä¸‹ã®çµ±åˆçµæœè¡¨ç¤ºã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç¢ºèªã—ã¦ãã ã•ã„", detailedResults, 'success');
            } else {
                log(`âŒ çµ±åˆå‡¦ç†ãƒ‡ãƒ¢å¤±æ•—: ${integrationResult.reason}`, detailedResults, 'error');
            }
        }

        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¡¨ç¤º
        function updatePerformanceMetrics(metrics) {
            performanceMetrics.innerHTML = '';
            for (const [key, data] of Object.entries(metrics)) {
                const card = document.createElement('div');
                card.className = 'metric-card';
                card.innerHTML = `
                    <div class="metric-value">${data.value}</div>
                    <div class="metric-label">${data.label}</div>
                `;
                performanceMetrics.appendChild(card);
            }
        }
    </script>
</body>
</html>