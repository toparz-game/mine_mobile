<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase4-1ãƒ†ã‚¹ãƒˆ: é«˜åº¦ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æœ€é©åŒ–</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: #00ff00;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1, h2, h3 {
            color: #ffff00;
            border-bottom: 2px solid #333;
            padding-bottom: 10px;
        }
        .test-section {
            background: #222;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border: 1px solid #444;
        }
        .success {
            color: #00ff00;
            font-weight: bold;
        }
        .error {
            color: #ff4444;
            font-weight: bold;
        }
        .info {
            color: #00ccff;
        }
        .warning {
            color: #ffaa00;
        }
        button {
            background: #333;
            color: #00ff00;
            border: 1px solid #555;
            padding: 10px 20px;
            cursor: pointer;
            margin: 5px;
            border-radius: 3px;
        }
        button:hover {
            background: #444;
        }
        .results {
            background: #111;
            padding: 10px;
            border-radius: 3px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .performance-stats {
            background: #001133;
            padding: 10px;
            border-radius: 3px;
            margin: 10px 0;
        }
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Phase4-1ãƒ†ã‚¹ãƒˆ: é«˜åº¦ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æœ€é©åŒ–</h1>
        
        <div class="test-section">
            <h2>ğŸ“Š Phase4-1ãƒ†ã‚¹ãƒˆæ¦‚è¦</h2>
            <p class="info">Phase4-1ã§å®Ÿè£…ã•ã‚ŒãŸ4ã¤ã®é«˜åº¦ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ æœ€é©åŒ–æ©Ÿèƒ½ã‚’ãƒ†ã‚¹ãƒˆ:</p>
            <ul>
                <li><strong>implementAdvancedPropagationBit()</strong>: é«˜åº¦åˆ¶ç´„ä¼æ’­ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </li>
                <li><strong>applyMachineLearningHeuristicsBit()</strong>: MLç³»ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯é©ç”¨</li>
                <li><strong>optimizeBacktrackingStrategyBit()</strong>: ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯æˆ¦ç•¥æœ€é©åŒ–</li>
                <li><strong>implementParallelProcessingBit()</strong>: ä¸¦åˆ—å‡¦ç†ãƒ“ãƒƒãƒˆå®Ÿè£…</li>
            </ul>
        </div>

        <div class="grid">
            <div>
                <div class="test-section">
                    <h3>ğŸ§  é«˜åº¦åˆ¶ç´„ä¼æ’­ãƒ†ã‚¹ãƒˆ</h3>
                    <button onclick="debugMethodAvailability()">ğŸ” ãƒ¡ã‚½ãƒƒãƒ‰å­˜åœ¨ç¢ºèª</button>
                    <button onclick="testAdvancedPropagation()">é«˜åº¦åˆ¶ç´„ä¼æ’­ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
                    <div class="performance-stats" id="propagation-stats" style="display:none;">
                        <h4>ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆ:</h4>
                        <div id="propagation-performance"></div>
                    </div>
                    <div class="results" id="propagation-results"></div>
                </div>

                <div class="test-section">
                    <h3>ğŸ¤– æ©Ÿæ¢°å­¦ç¿’ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯ãƒ†ã‚¹ãƒˆ</h3>
                    <button onclick="testMachineLearningHeuristics()">MLãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
                    <div class="performance-stats" id="ml-stats" style="display:none;">
                        <h4>ç‰¹å¾´é‡æŠ½å‡ºçµæœ:</h4>
                        <div id="ml-features"></div>
                    </div>
                    <div class="results" id="ml-results"></div>
                </div>
            </div>

            <div>
                <div class="test-section">
                    <h3>ğŸ”„ ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯æˆ¦ç•¥æœ€é©åŒ–ãƒ†ã‚¹ãƒˆ</h3>
                    <button onclick="testBacktrackingOptimization()">ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯æœ€é©åŒ–ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
                    <div class="performance-stats" id="backtrack-stats" style="display:none;">
                        <h4>æˆ¦ç•¥æ¯”è¼ƒçµæœ:</h4>
                        <div id="backtrack-comparison"></div>
                    </div>
                    <div class="results" id="backtrack-results"></div>
                </div>

                <div class="test-section">
                    <h3>âš¡ ä¸¦åˆ—å‡¦ç†ãƒ†ã‚¹ãƒˆ</h3>
                    <button onclick="testParallelProcessing()">ä¸¦åˆ—å‡¦ç†ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
                    <div class="performance-stats" id="parallel-stats" style="display:none;">
                        <h4>ä¸¦åˆ—å‡¦ç†çµ±è¨ˆ:</h4>
                        <div id="parallel-performance"></div>
                    </div>
                    <div class="results" id="parallel-results"></div>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h3>ğŸ¯ çµ±åˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ</h3>
            <button onclick="runComprehensivePerformanceTest()">åŒ…æ‹¬çš„ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
            <div class="performance-stats" id="comprehensive-stats" style="display:none;">
                <h4>å…¨æ©Ÿèƒ½çµ±åˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹:</h4>
                <div id="comprehensive-performance"></div>
            </div>
            <div class="results" id="comprehensive-results"></div>
        </div>
    </div>

    <script src="modules/bit-minesweeper.js"></script>
    <script src="modules/simple-bit-csp.js"></script>
    <script>
        // ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ¢ãƒƒã‚¯ã‚²ãƒ¼ãƒ ã¨CSPã‚½ãƒ«ãƒãƒ¼
        let mockGame, cspSolver;
        
        function initializeMockEnvironment() {
            // BitMinesweeperSystemã®åˆæœŸåŒ–
            const bitSystem = new BitMinesweeperSystem(32, 64);
            
            mockGame = {
                rows: 16,
                cols: 30,
                revealed: Array(16).fill().map(() => Array(30).fill(false)),
                flagged: Array(16).fill().map(() => Array(30).fill(false)),
                mineField: Array(16).fill().map(() => Array(30).fill(false))
            };
            
            // CSPã‚½ãƒ«ãƒãƒ¼ã®åˆæœŸåŒ–
            cspSolver = new SimpleBitCSP(mockGame, bitSystem);
            
            // ãƒ‡ãƒãƒƒã‚°: Phase4-1ãƒ¡ã‚½ãƒƒãƒ‰ã®å­˜åœ¨ç¢ºèª
            console.log('Phase4-1ãƒ†ã‚¹ãƒˆç’°å¢ƒåˆæœŸåŒ–å®Œäº†');
            console.log('CSP Solver:', cspSolver);
            console.log('implementAdvancedPropagationBit method exists:', typeof cspSolver.implementAdvancedPropagationBit);
            console.log('applyMachineLearningHeuristicsBit method exists:', typeof cspSolver.applyMachineLearningHeuristicsBit);
            console.log('optimizeBacktrackingStrategyBit method exists:', typeof cspSolver.optimizeBacktrackingStrategyBit);
            console.log('implementParallelProcessingBit method exists:', typeof cspSolver.implementParallelProcessingBit);
            
            // åˆ©ç”¨å¯èƒ½ãªãƒ¡ã‚½ãƒƒãƒ‰ä¸€è¦§ã‚’è¡¨ç¤º
            console.log('Available methods:', Object.getOwnPropertyNames(cspSolver).filter(name => typeof cspSolver[name] === 'function'));
        }

        function createTestConstraints() {
            // ãƒ†ã‚¹ãƒˆç”¨ã®åˆ¶ç´„ã‚»ãƒƒãƒˆã‚’ç”Ÿæˆ
            return [
                { cells: ['5,10', '5,11', '6,10'], count: 1 },
                { cells: ['5,11', '5,12', '6,11', '6,12'], count: 2 },
                { cells: ['6,10', '6,11', '7,10'], count: 1 },
                { cells: ['7,10', '7,11', '8,10', '8,11'], count: 2 },
                { cells: ['8,10', '8,11', '8,12'], count: 1 },
                { cells: ['10,15', '10,16', '11,15'], count: 1 },
                { cells: ['11,15', '11,16', '12,15', '12,16'], count: 3 },
                { cells: ['12,15', '12,16', '13,15'], count: 2 }
            ];
        }

        function createLargeTestConstraints() {
            // å¤§è¦æ¨¡ãƒ†ã‚¹ãƒˆç”¨ã®åˆ¶ç´„ã‚»ãƒƒãƒˆ
            const constraints = [];
            for (let i = 0; i < 20; i++) {
                for (let j = 0; j < 15; j++) {
                    const cells = [];
                    for (let di = 0; di <= 1; di++) {
                        for (let dj = 0; dj <= 1; dj++) {
                            if (i + di < 16 && j + dj < 30) {
                                cells.push(`${i + di},${j + dj}`);
                            }
                        }
                    }
                    if (cells.length >= 2) {
                        constraints.push({ 
                            cells, 
                            count: Math.floor(Math.random() * Math.min(cells.length, 3)) + 1 
                        });
                    }
                }
            }
            return constraints;
        }

        function debugMethodAvailability() {
            const resultsDiv = document.getElementById('propagation-results');
            
            let output = `ğŸ” ãƒ¡ã‚½ãƒƒãƒ‰å­˜åœ¨ç¢ºèªçµæœ:\n\n`;
            
            if (!cspSolver) {
                output += `âŒ cspSolver ãŒæœªåˆæœŸåŒ–ã§ã™\n`;
                resultsDiv.innerHTML = output;
                return;
            }
            
            output += `âœ… cspSolver ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç¢ºèª: ${typeof cspSolver}\n`;
            output += `âœ… cspSolver ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿: ${cspSolver.constructor.name}\n\n`;
            
            const phase4Methods = [
                'implementAdvancedPropagationBit',
                'applyMachineLearningHeuristicsBit', 
                'optimizeBacktrackingStrategyBit',
                'implementParallelProcessingBit'
            ];
            
            output += `Phase4-1ãƒ¡ã‚½ãƒƒãƒ‰å­˜åœ¨ç¢ºèª:\n`;
            phase4Methods.forEach(method => {
                const exists = typeof cspSolver[method] === 'function';
                output += `  ${exists ? 'âœ…' : 'âŒ'} ${method}: ${typeof cspSolver[method]}\n`;
            });
            
            // å…¨ãƒ¡ã‚½ãƒƒãƒ‰æ•°ã‚’ç¢ºèªï¼ˆãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ãƒã‚§ãƒ¼ãƒ³ã‚‚å«ã‚€ï¼‰
            const allMethods = [];
            let obj = cspSolver;
            while (obj && obj !== Object.prototype) {
                Object.getOwnPropertyNames(obj).forEach(name => {
                    if (typeof cspSolver[name] === 'function' && !allMethods.includes(name)) {
                        allMethods.push(name);
                    }
                });
                obj = Object.getPrototypeOf(obj);
            }
            output += `\nğŸ“Š åˆ©ç”¨å¯èƒ½ãƒ¡ã‚½ãƒƒãƒ‰ç·æ•°: ${allMethods.length}\n`;
            
            // Phaseé–¢é€£ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ãƒã‚§ãƒƒã‚¯
            const phaseMethods = allMethods.filter(name => 
                name.toLowerCase().includes('phase') || 
                name.toLowerCase().includes('bit') ||
                name.toLowerCase().includes('advanced') ||
                name.toLowerCase().includes('machine') ||
                name.toLowerCase().includes('parallel')
            );
            output += `ğŸ¯ Phase/Bité–¢é€£ãƒ¡ã‚½ãƒƒãƒ‰: ${phaseMethods.length}å€‹\n`;
            phaseMethods.slice(0, 10).forEach(method => {
                output += `  - ${method}\n`;
            });
            
            resultsDiv.innerHTML = output;
        }

        function testAdvancedPropagation() {
            const constraints = createTestConstraints();
            const resultsDiv = document.getElementById('propagation-results');
            const statsDiv = document.getElementById('propagation-stats');
            const performanceDiv = document.getElementById('propagation-performance');
            
            resultsDiv.innerHTML = 'ğŸ”„ é«˜åº¦åˆ¶ç´„ä¼æ’­ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­...';
            statsDiv.style.display = 'block';
            
            // ã¾ãšãƒ¡ã‚½ãƒƒãƒ‰ã®å­˜åœ¨ã‚’ç¢ºèª
            if (!cspSolver || typeof cspSolver.implementAdvancedPropagationBit !== 'function') {
                resultsDiv.innerHTML = `<span class="error">âŒ implementAdvancedPropagationBit ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“</span>\n` +
                    `cspSolver: ${typeof cspSolver}\n` +
                    `method type: ${typeof cspSolver?.implementAdvancedPropagationBit}`;
                return;
            }
            
            try {
                const assignments = new Map();
                assignments.set('5,10', 0); // æ—¢çŸ¥ã®å®‰å…¨ã‚»ãƒ«
                
                const startTime = performance.now();
                const result = cspSolver.implementAdvancedPropagationBit(constraints, assignments);
                const endTime = performance.now();
                
                let output = `<span class="success">âœ… é«˜åº¦åˆ¶ç´„ä¼æ’­ãƒ†ã‚¹ãƒˆæˆåŠŸ</span>\n\n`;
                
                if (result.success) {
                    output += `â±ï¸ å‡¦ç†æ™‚é–“: ${result.processingTime.toFixed(3)}ms\n`;
                    output += `ğŸ”„ ä¼æ’­ãƒ©ã‚¦ãƒ³ãƒ‰æ•°: ${result.propagationRounds}\n`;
                    output += `ğŸ“Š å˜ä½ä¼æ’­æ•°: ${result.unitPropagations.length}\n`;
                    output += `ğŸ§® å‰Šæ¸›ã•ã‚ŒãŸãƒ‰ãƒ¡ã‚¤ãƒ³æ•°: ${result.reducedDomains.size}\n\n`;
                    
                    // ãƒ‰ãƒ¡ã‚¤ãƒ³å‰Šæ¸›ã®è©³ç´°
                    output += `ğŸ“‹ ãƒ‰ãƒ¡ã‚¤ãƒ³å‰Šæ¸›çµæœ:\n`;
                    let reducedCells = 0;
                    result.reducedDomains.forEach((domain, cell) => {
                        if (domain.length === 1) {
                            output += `  ${cell}: ${domain[0] === 1 ? 'åœ°é›·' : 'å®‰å…¨'}\n`;
                            reducedCells++;
                        }
                    });
                    output += `å‰Šæ¸›ã•ã‚ŒãŸã‚»ãƒ«æ•°: ${reducedCells}\n`;
                    
                    // å˜ä½ä¼æ’­ã®è©³ç´°
                    if (result.unitPropagations.length > 0) {
                        output += `\nğŸ“ˆ å˜ä½ä¼æ’­è©³ç´°:\n`;
                        result.unitPropagations.forEach(prop => {
                            output += `  ${prop.cell}: ${prop.value === 1 ? 'åœ°é›·' : 'å®‰å…¨'} (ç†ç”±: ${prop.reason})\n`;
                        });
                    }
                    
                    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆ
                    performanceDiv.innerHTML = `
                        å‡¦ç†æ™‚é–“: ${result.processingTime.toFixed(3)}ms<br>
                        ä¼æ’­åŠ¹ç‡: ${(reducedCells / result.propagationRounds).toFixed(2)} ã‚»ãƒ«/ãƒ©ã‚¦ãƒ³ãƒ‰<br>
                        åˆ¶ç´„åŠ¹æœç‡: ${(reducedCells / constraints.length * 100).toFixed(1)}%
                    `;
                    
                } else {
                    output += `<span class="error">âŒ ã‚¨ãƒ©ãƒ¼: ${result.error}</span>\n`;
                    if (result.inconsistentConstraint) {
                        output += `çŸ›ç›¾åˆ¶ç´„: ${JSON.stringify(result.inconsistentConstraint)}\n`;
                    }
                }
                
                resultsDiv.innerHTML = output;
                
            } catch (error) {
                resultsDiv.innerHTML = `<span class="error">âŒ ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}</span>`;
                console.error('é«˜åº¦åˆ¶ç´„ä¼æ’­ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
            }
        }

        function testMachineLearningHeuristics() {
            const constraints = createTestConstraints();
            const resultsDiv = document.getElementById('ml-results');
            const statsDiv = document.getElementById('ml-stats');
            const featuresDiv = document.getElementById('ml-features');
            
            resultsDiv.innerHTML = 'ğŸ”„ æ©Ÿæ¢°å­¦ç¿’ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­...';
            statsDiv.style.display = 'block';
            
            try {
                const historicalData = {
                    successfulStrategies: ['balanced', 'heuristic_heavy'],
                    failedStrategies: ['brute_force']
                };
                
                const result = cspSolver.applyMachineLearningHeuristicsBit(constraints, historicalData);
                
                let output = `<span class="success">âœ… æ©Ÿæ¢°å­¦ç¿’ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯ãƒ†ã‚¹ãƒˆæˆåŠŸ</span>\n\n`;
                
                if (result.success) {
                    output += `â±ï¸ å‡¦ç†æ™‚é–“: ${result.processingTime.toFixed(3)}ms\n`;
                    output += `ğŸ¯ é¸æŠã•ã‚ŒãŸæˆ¦ç•¥: ${result.selectedStrategy}\n\n`;
                    
                    // ç‰¹å¾´é‡è©³ç´°
                    const features = result.features;
                    output += `ğŸ“Š åˆ¶ç´„ç‰¹å¾´é‡:\n`;
                    output += `  åˆ¶ç´„æ•°: ${features.constraintCount}\n`;
                    output += `  å¹³å‡åˆ¶ç´„ã‚µã‚¤ã‚º: ${features.averageConstraintSize.toFixed(2)}\n`;
                    output += `  æœ€å¤§åˆ¶ç´„ã‚µã‚¤ã‚º: ${features.maxConstraintSize}\n`;
                    output += `  åˆ¶ç´„å¯†åº¦: ${features.constraintDensity.toFixed(2)}\n`;
                    output += `  è¤‡é›‘åº¦ã‚¹ã‚³ã‚¢: ${features.complexityScore.toFixed(2)}\n\n`;
                    
                    // é‡ã¿è©³ç´°
                    output += `âš–ï¸ MLé‡ã¿è¨­å®š:\n`;
                    Object.entries(result.heuristicWeights).forEach(([key, value]) => {
                        output += `  ${key}: ${value.toFixed(3)}\n`;
                    });
                    
                    // ã‚»ãƒ«å„ªå…ˆåº¦ãƒˆãƒƒãƒ—5
                    output += `\nğŸ† ã‚»ãƒ«å„ªå…ˆåº¦ãƒˆãƒƒãƒ—5:\n`;
                    const sortedCells = Array.from(result.cellPriorities.entries())
                        .sort((a, b) => b[1].score - a[1].score)
                        .slice(0, 5);
                    sortedCells.forEach(([cell, data], index) => {
                        output += `  ${index + 1}. ${cell}: ã‚¹ã‚³ã‚¢ ${data.score.toFixed(2)} (æ¥ç¶šæ€§: ${data.connectivity})\n`;
                    });
                    
                    // åˆ¶ç´„å„ªå…ˆåº¦ãƒˆãƒƒãƒ—3
                    output += `\nğŸ“Š åˆ¶ç´„å„ªå…ˆåº¦ãƒˆãƒƒãƒ—3:\n`;
                    result.constraintPriorities.slice(0, 3).forEach((item, index) => {
                        output += `  ${index + 1}. ã‚»ãƒ«${item.constraint.cells.length}å€‹, ã‚¹ã‚³ã‚¢: ${item.score.toFixed(2)}\n`;
                    });
                    
                    // ç‰¹å¾´é‡ã‚’è¡¨ç¤º
                    featuresDiv.innerHTML = `
                        åˆ¶ç´„æ•°: ${features.constraintCount}<br>
                        å¹³å‡ã‚µã‚¤ã‚º: ${features.averageConstraintSize.toFixed(2)}<br>
                        å¯†åº¦: ${features.constraintDensity.toFixed(2)}<br>
                        è¤‡é›‘åº¦: ${features.complexityScore.toFixed(2)}<br>
                        é¸æŠæˆ¦ç•¥: <strong>${result.selectedStrategy}</strong>
                    `;
                    
                } else {
                    output += `<span class="error">âŒ ã‚¨ãƒ©ãƒ¼: ${result.error}</span>\n`;
                }
                
                resultsDiv.innerHTML = output;
                
            } catch (error) {
                resultsDiv.innerHTML = `<span class="error">âŒ ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}</span>`;
                console.error('MLãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
            }
        }

        function testBacktrackingOptimization() {
            const constraints = createTestConstraints();
            const resultsDiv = document.getElementById('backtrack-results');
            const statsDiv = document.getElementById('backtrack-stats');
            const comparisonDiv = document.getElementById('backtrack-comparison');
            
            resultsDiv.innerHTML = 'ğŸ”„ ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯æˆ¦ç•¥æœ€é©åŒ–ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­...';
            statsDiv.style.display = 'block';
            
            try {
                const mlResult = cspSolver.applyMachineLearningHeuristicsBit(constraints);
                const strategies = ['brute_force', 'sparse_optimized', 'balanced', 'heuristic_heavy'];
                const results = {};
                
                let output = `<span class="success">âœ… ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯æˆ¦ç•¥æœ€é©åŒ–ãƒ†ã‚¹ãƒˆæˆåŠŸ</span>\n\n`;
                
                // å„æˆ¦ç•¥ã§ãƒ†ã‚¹ãƒˆ
                for (const strategy of strategies) {
                    const result = cspSolver.optimizeBacktrackingStrategyBit(
                        constraints, 
                        mlResult.cellPriorities, 
                        strategy
                    );
                    results[strategy] = result;
                    
                    if (result.success) {
                        output += `ğŸ¯ æˆ¦ç•¥: ${strategy}\n`;
                        output += `  â±ï¸ è¨­å®šæ™‚é–“: ${result.processingTime.toFixed(3)}ms\n`;
                        output += `  ğŸ“Š ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯é †åº: ${result.backtrackOrder.length}ã‚»ãƒ«\n`;
                        output += `  ğŸ›¡ï¸ ãƒ—ãƒ«ãƒ¼ãƒ‹ãƒ³ã‚°è¨­å®š: ${JSON.stringify(result.pruningStrategy).substring(0, 50)}...\n`;
                        output += `  ğŸ§  å¤±æ•—å­¦ç¿’: ${result.failureLearningConfig.enableNoGoodLearning ? 'æœ‰åŠ¹' : 'ç„¡åŠ¹'}\n\n`;
                    }
                }
                
                // æˆ¦ç•¥æ¯”è¼ƒ
                let comparison = 'æˆ¦ç•¥æ¯”è¼ƒçµæœ:<br>';
                strategies.forEach(strategy => {
                    const result = results[strategy];
                    if (result.success) {
                        comparison += `${strategy}: è¨­å®šæ™‚é–“ ${result.processingTime.toFixed(3)}ms<br>`;
                    }
                });
                
                comparisonDiv.innerHTML = comparison;
                resultsDiv.innerHTML = output;
                
            } catch (error) {
                resultsDiv.innerHTML = `<span class="error">âŒ ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}</span>`;
                console.error('ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯æœ€é©åŒ–ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
            }
        }

        function testParallelProcessing() {
            const constraintGroups = [
                createTestConstraints().slice(0, 3),
                createTestConstraints().slice(3, 6),
                createTestConstraints().slice(6, 8)
            ];
            
            const resultsDiv = document.getElementById('parallel-results');
            const statsDiv = document.getElementById('parallel-stats');
            const performanceDiv = document.getElementById('parallel-performance');
            
            resultsDiv.innerHTML = 'ğŸ”„ ä¸¦åˆ—å‡¦ç†ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­...';
            statsDiv.style.display = 'block';
            
            cspSolver.implementParallelProcessingBit(constraintGroups, 2).then(result => {
                let output = `<span class="success">âœ… ä¸¦åˆ—å‡¦ç†ãƒ†ã‚¹ãƒˆæˆåŠŸ</span>\n\n`;
                
                if (result.success) {
                    output += `â±ï¸ ç·å‡¦ç†æ™‚é–“: ${result.processingTime.toFixed(3)}ms\n`;
                    output += `ğŸ”„ ä¸¦åˆ—å‡¦ç†: ${result.parallelProcessing ? 'æœ‰åŠ¹' : 'ç„¡åŠ¹'}\n`;
                    
                    if (result.parallelProcessing) {
                        output += `ğŸ‘· ãƒ¯ãƒ¼ã‚«ãƒ¼æ•°: ${result.workerCount}\n`;
                        output += `ğŸ“Š å‡¦ç†ã‚°ãƒ«ãƒ¼ãƒ—æ•°: ${result.result.stats.totalGroups}\n`;
                        output += `ğŸ¯ ç·ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³æ•°: ${result.result.stats.totalSolutions}\n`;
                        output += `âš¡ æœ€å¤§ãƒ¯ãƒ¼ã‚«ãƒ¼æ™‚é–“: ${result.result.stats.maxWorkerTime.toFixed(3)}ms\n`;
                        output += `ğŸš€ æœ€å°ãƒ¯ãƒ¼ã‚«ãƒ¼æ™‚é–“: ${result.result.stats.minWorkerTime.toFixed(3)}ms\n`;
                    } else {
                        output += `âš ï¸ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç†ç”±: ${result.fallbackReason}\n`;
                    }
                    
                    // ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³è©³ç´°
                    if (result.result.solutions) {
                        output += `\nğŸ“‹ è§£æ±ºçµæœè©³ç´°:\n`;
                        result.result.solutions.forEach((solution, index) => {
                            if (solution.solutions) {
                                output += `  ã‚°ãƒ«ãƒ¼ãƒ—${index + 1}: ${solution.solutions.length}ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³\n`;
                            }
                        });
                    }
                    
                    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆ
                    performanceDiv.innerHTML = `
                        ä¸¦åˆ—å‡¦ç†: ${result.parallelProcessing ? 'æˆåŠŸ' : 'ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯'}<br>
                        ç·å‡¦ç†æ™‚é–“: ${result.processingTime.toFixed(3)}ms<br>
                        åŠ¹ç‡æŒ‡æ¨™: ${result.parallelProcessing ? 
                            (result.result.stats.totalSolutions / result.processingTime).toFixed(2) + ' sol/ms' : 
                            'é †æ¬¡å‡¦ç†'}
                    `;
                    
                } else {
                    output += `<span class="error">âŒ ã‚¨ãƒ©ãƒ¼: ${result.error}</span>\n`;
                }
                
                resultsDiv.innerHTML = output;
                
            }).catch(error => {
                resultsDiv.innerHTML = `<span class="error">âŒ ä¸¦åˆ—å‡¦ç†ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}</span>`;
                console.error('ä¸¦åˆ—å‡¦ç†ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
            });
        }

        function runComprehensivePerformanceTest() {
            const resultsDiv = document.getElementById('comprehensive-results');
            const statsDiv = document.getElementById('comprehensive-stats');
            const performanceDiv = document.getElementById('comprehensive-performance');
            
            resultsDiv.innerHTML = 'ğŸ”„ åŒ…æ‹¬çš„ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­...';
            statsDiv.style.display = 'block';
            
            try {
                const testSizes = [
                    { name: 'å°è¦æ¨¡', constraints: createTestConstraints() },
                    { name: 'ä¸­è¦æ¨¡', constraints: createLargeTestConstraints().slice(0, 50) },
                    { name: 'å¤§è¦æ¨¡', constraints: createLargeTestConstraints() }
                ];
                
                let output = `<span class="success">âœ… åŒ…æ‹¬çš„ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹</span>\n\n`;
                const performanceResults = {};
                
                testSizes.forEach(testCase => {
                    output += `ğŸ“Š ${testCase.name}ãƒ†ã‚¹ãƒˆ (åˆ¶ç´„æ•°: ${testCase.constraints.length}):\n`;
                    
                    // 1. é«˜åº¦åˆ¶ç´„ä¼æ’­
                    const propagationStart = performance.now();
                    const propagationResult = cspSolver.implementAdvancedPropagationBit(testCase.constraints);
                    const propagationTime = performance.now() - propagationStart;
                    
                    // 2. MLãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯
                    const mlStart = performance.now();
                    const mlResult = cspSolver.applyMachineLearningHeuristicsBit(testCase.constraints);
                    const mlTime = performance.now() - mlStart;
                    
                    // 3. ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯æœ€é©åŒ–
                    const backtrackStart = performance.now();
                    const backtrackResult = cspSolver.optimizeBacktrackingStrategyBit(
                        testCase.constraints, 
                        mlResult.cellPriorities
                    );
                    const backtrackTime = performance.now() - backtrackStart;
                    
                    const totalTime = propagationTime + mlTime + backtrackTime;
                    
                    output += `  åˆ¶ç´„ä¼æ’­: ${propagationTime.toFixed(3)}ms\n`;
                    output += `  MLãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯: ${mlTime.toFixed(3)}ms\n`;
                    output += `  ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯æœ€é©åŒ–: ${backtrackTime.toFixed(3)}ms\n`;
                    output += `  åˆè¨ˆæ™‚é–“: ${totalTime.toFixed(3)}ms\n`;
                    output += `  å¹³å‡æ™‚é–“/åˆ¶ç´„: ${(totalTime / testCase.constraints.length).toFixed(3)}ms\n\n`;
                    
                    performanceResults[testCase.name] = {
                        totalTime,
                        constraintCount: testCase.constraints.length,
                        avgTimePerConstraint: totalTime / testCase.constraints.length
                    };
                });
                
                // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›®æ¨™ã¨ã®æ¯”è¼ƒ
                output += `ğŸ¯ Phase4-1ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›®æ¨™é”æˆçŠ¶æ³:\n`;
                const smallScaleTime = performanceResults['å°è¦æ¨¡']?.avgTimePerConstraint || 0;
                const targetTime = 0.05; // ç›®æ¨™: <0.05ms per constraint (æ¦‚ç®—)
                
                if (smallScaleTime < targetTime) {
                    output += `  âœ… å°è¦æ¨¡å‡¦ç†ç›®æ¨™é”æˆ: ${smallScaleTime.toFixed(3)}ms < ${targetTime}ms\n`;
                } else {
                    output += `  âš ï¸ å°è¦æ¨¡å‡¦ç†ç›®æ¨™æœªé”: ${smallScaleTime.toFixed(3)}ms > ${targetTime}ms\n`;
                }
                
                // çµ±è¨ˆã‚µãƒãƒªãƒ¼
                let performanceSummary = 'Phase4-1çµ±åˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹:<br>';
                Object.entries(performanceResults).forEach(([size, data]) => {
                    performanceSummary += `${size}: ${data.totalTime.toFixed(3)}ms (${data.constraintCount}åˆ¶ç´„)<br>`;
                });
                performanceSummary += `<br>ğŸ† Phase4-1å®Ÿè£…æˆåŠŸ: 4ã¤ã®é«˜åº¦æœ€é©åŒ–æ©Ÿèƒ½ã™ã¹ã¦å‹•ä½œç¢ºèª`;
                
                performanceDiv.innerHTML = performanceSummary;
                resultsDiv.innerHTML = output;
                
            } catch (error) {
                resultsDiv.innerHTML = `<span class="error">âŒ åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}</span>`;
                console.error('åŒ…æ‹¬çš„ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
            }
        }

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã®åˆæœŸåŒ–
        window.addEventListener('load', () => {
            initializeMockEnvironment();
            console.log('Phase4-1ãƒ†ã‚¹ãƒˆãƒšãƒ¼ã‚¸åˆæœŸåŒ–å®Œäº†');
        });
    </script>
</body>
</html>