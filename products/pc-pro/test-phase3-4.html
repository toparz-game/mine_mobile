<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase3-4: å¤§è¦æ¨¡å®Œå…¨æ¢ç´¢ã®æ®µéšçš„æœ€é©åŒ–ãƒ†ã‚¹ãƒˆ</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            background: linear-gradient(135deg, #FF5722 0%, #E64A19 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }
        .test-section {
            background-color: #2d2d2d;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .success { color: #4CAF50; }
        .error { color: #f44336; }
        .warning { color: #ff9800; }
        .info { color: #2196F3; }
        .test-button {
            background: linear-gradient(45deg, #FF5722, #E64A19);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: all 0.3s;
        }
        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 87, 34, 0.4);
        }
        .test-results {
            background-color: #1e1e1e;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            max-height: 400px;
            overflow-y: auto;
        }
        .performance-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .metric-card {
            background-color: #333;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #FF5722;
        }
        .metric-label {
            font-size: 14px;
            color: #bbb;
            margin-top: 5px;
        }
        .optimization-demo {
            background-color: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ Phase3-4: å¤§è¦æ¨¡å®Œå…¨æ¢ç´¢ã®æ®µéšçš„æœ€é©åŒ–</h1>
            <p>ç›®æ¨™: å¤§è¦æ¨¡åˆ¶ç´„ã‚»ãƒƒãƒˆï¼ˆ>15ã‚»ãƒ«ï¼‰ã«å¯¾ã™ã‚‹æœ€é©åŒ–</p>
            <p>æœ€é©åŒ–æ‰‹æ³•: åˆ†å‰²æˆ¦ç•¥ãƒ»ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯æåˆˆã‚Šãƒ»æ¢ç´¢é †åºæœ€é©åŒ–ãƒ»ãƒ¡ãƒ¢ãƒªç®¡ç†</p>
        </div>

        <div class="test-section">
            <h2>ğŸ“‹ Phase3-4 æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</h2>
            <button class="test-button" onclick="testPartitionLargeConstraintSet()">1. partitionLargeConstraintSetBit() ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testApplyHeuristicPruning()">2. applyHeuristicPruningBit() ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testOptimizeSearchOrder()">3. optimizeSearchOrderBit() ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testManageLargeSetMemory()">4. manageLargeSetMemoryBit() ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="runAllTests()">ğŸ¯ å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
            <button class="test-button" onclick="clearResults()" style="background: linear-gradient(45deg, #f44336, #d32f2f);">ğŸ§¹ çµæœã‚¯ãƒªã‚¢</button>
            <div id="testResults" class="test-results"></div>
        </div>

        <div class="test-section">
            <h2>âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š</h2>
            <button class="test-button" onclick="benchmarkLargeSetPartitioning()">å¤§è¦æ¨¡ã‚»ãƒƒãƒˆåˆ†å‰²ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯</button>
            <button class="test-button" onclick="benchmarkHeuristicPruning()">ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯æåˆˆã‚Šãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯</button>
            <button class="test-button" onclick="benchmarkSearchOrderOptimization()">æ¢ç´¢é †åºæœ€é©åŒ–ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯</button>
            <button class="test-button" onclick="benchmarkMemoryManagement()">ãƒ¡ãƒ¢ãƒªç®¡ç†ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯</button>
            <button class="test-button" onclick="benchmarkExtremeScaleTest()">âœ¨ æ¥µé™è¦æ¨¡ãƒ†ã‚¹ãƒˆ (50ã‚»ãƒ«)</button>
            <div id="performanceResults" class="test-results"></div>
            <div id="performanceMetrics" class="performance-metrics"></div>
        </div>

        <div class="test-section">
            <h2>ğŸ” è©³ç´°å‹•ä½œãƒ†ã‚¹ãƒˆ</h2>
            <button class="test-button" onclick="testComplexPartitioningScenarios()">è¤‡é›‘åˆ†å‰²ã‚·ãƒŠãƒªã‚ªãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testAdvancedPruningTechniques()">é«˜åº¦æåˆˆã‚ŠæŠ€æ³•ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testAdaptiveOptimization()">é©å¿œçš„æœ€é©åŒ–ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testOptimizationDemo()">ğŸª æœ€é©åŒ–ãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ãƒ¢</button>
            <div id="detailedResults" class="test-results"></div>
        </div>

        <div class="test-section">
            <h2>ğŸ“Š æœ€é©åŒ–çµæœè¡¨ç¤º</h2>
            <div id="optimizationDemo" class="optimization-demo"></div>
        </div>
    </div>

    <script src="modules/bit-minesweeper.js"></script>
    <script src="modules/simple-bit-csp.js"></script>
    <script>
        let testResults, performanceResults, detailedResults, performanceMetrics, optimizationDemo;
        let mockGame, bitSystem, bitCSP;

        // DOMãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã‹ã‚‰åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', function() {
            testResults = document.getElementById('testResults');
            performanceResults = document.getElementById('performanceResults');
            detailedResults = document.getElementById('detailedResults');
            performanceMetrics = document.getElementById('performanceMetrics');
            optimizationDemo = document.getElementById('optimizationDemo');

            // ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ¢ãƒƒã‚¯ã‚²ãƒ¼ãƒ ç’°å¢ƒ
            mockGame = {
                rows: 16,
                cols: 16,
                mines: 40,
                board: Array(16).fill().map(() => Array(16).fill(0)),
                isValidCoord: (row, col) => row >= 0 && row < 16 && col >= 0 && col < 16
            };

            // BitMinesweeperSystemã¨SimpleBitCSPã‚’åˆæœŸåŒ–
            try {
                bitSystem = new BitMinesweeperSystem(mockGame);
                bitCSP = new SimpleBitCSP(mockGame, bitSystem);
                log("ğŸš€ Phase3-4ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†", testResults, 'success');
                log("å¤§è¦æ¨¡å®Œå…¨æ¢ç´¢ã®æ®µéšçš„æœ€é©åŒ–ã‚’ãƒ†ã‚¹ãƒˆã—ã¾ã™", testResults, 'info');
            } catch (error) {
                console.error('åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                if (testResults) {
                    log(`âŒ åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, testResults, 'error');
                }
            }
        });

        function log(message, element = testResults, className = '') {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}\n`;
            element.textContent += logMessage;
            if (className) {
                element.className += ` ${className}`;
            }
            element.scrollTop = element.scrollHeight;
        }

        function clearResults() {
            testResults.textContent = '';
            performanceResults.textContent = '';
            detailedResults.textContent = '';
            performanceMetrics.innerHTML = '';
            optimizationDemo.innerHTML = '';
        }

        // ãƒ†ã‚¹ãƒˆç”¨ã®å¤§è¦æ¨¡åˆ¶ç´„ã‚»ãƒƒãƒˆã‚’ç”Ÿæˆ
        function createLargeConstraintSet(cellCount = 20, constraintCount = 5) {
            const cells = [];
            
            // ã‚»ãƒ«ç”Ÿæˆï¼ˆæ ¼å­çŠ¶é…ç½®ï¼‰
            for (let i = 0; i < cellCount; i++) {
                const row = Math.floor(i / 4);
                const col = i % 4;
                cells.push({ row, col });
            }
            
            // åˆ¶ç´„ç”Ÿæˆ
            const constraints = [];
            for (let i = 0; i < constraintCount; i++) {
                const startIdx = Math.floor(i * cellCount / constraintCount);
                const endIdx = Math.min(startIdx + 4, cellCount);
                const constraintCells = cells.slice(startIdx, endIdx);
                
                constraints.push({
                    id: i,
                    cells: constraintCells,
                    count: Math.floor(constraintCells.length * 0.4) + 1
                });
            }
            
            return {
                cells: cells,
                constraints: constraints,
                complexity: Math.pow(2, cellCount)
            };
        }

        // 1. partitionLargeConstraintSetBit() ãƒ†ã‚¹ãƒˆ
        function testPartitionLargeConstraintSet() {
            log("=== partitionLargeConstraintSetBit() ãƒ†ã‚¹ãƒˆé–‹å§‹ ===", testResults, 'info');
            
            // bitCSPãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if (!bitCSP) {
                log("âŒ bitCSP ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚", testResults, 'error');
                return false;
            }
            
            try {
                // ãƒ†ã‚¹ãƒˆ1: åŸºæœ¬çš„ãªå¤§è¦æ¨¡ã‚»ãƒƒãƒˆåˆ†å‰²
                const largeSet = createLargeConstraintSet(20, 4);
                const result1 = bitCSP.partitionLargeConstraintSetBit(largeSet);
                
                log(`${result1.success ? 'âœ…' : 'âŒ'} åŸºæœ¬åˆ†å‰²ãƒ†ã‚¹ãƒˆ (20ã‚»ãƒ«): ${result1.success ? 'æˆåŠŸ' : 'å¤±æ•—'}`, testResults, 
                    result1.success ? 'success' : 'error');
                
                if (result1.success) {
                    log(`   - åˆ†å‰²æ•°: ${result1.partitionCount}`, testResults);
                    log(`   - å¹³å‡åˆ†å‰²ã‚µã‚¤ã‚º: ${result1.averagePartitionSize.toFixed(1)}ã‚»ãƒ«`, testResults);
                    log(`   - æœ€å¤§åˆ†å‰²è¤‡é›‘åº¦: ${result1.maxPartitionComplexity.toLocaleString()}`, testResults);
                    log(`   - ã‚ªãƒ¼ãƒãƒ¼ãƒ©ãƒƒãƒ—æœ‰ç„¡: ${result1.hasOverlaps ? 'ã‚ã‚Š' : 'ãªã—'}`, testResults);
                    log(`   - å®Ÿè¡Œæ™‚é–“: ${result1.executionTime.toFixed(4)}ms`, testResults);
                } else {
                    log(`   - å¤±æ•—ç†ç”±: ${result1.reason}`, testResults, 'error');
                    if (result1.error) log(`   - ã‚¨ãƒ©ãƒ¼: ${result1.error}`, testResults, 'error');
                }
                
                if (!result1.success) {
                    log("âŒ partitionLargeConstraintSetBit() ãƒ†ã‚¹ãƒˆå¤±æ•—", testResults, 'error');
                    return false;
                }

                // ãƒ†ã‚¹ãƒˆ2: è¶…å¤§è¦æ¨¡ã‚»ãƒƒãƒˆåˆ†å‰²
                const megaLargeSet = createLargeConstraintSet(35, 8);
                const result2 = bitCSP.partitionLargeConstraintSetBit(megaLargeSet);
                
                log(`${result2.success ? 'âœ…' : 'âŒ'} è¶…å¤§è¦æ¨¡åˆ†å‰²ãƒ†ã‚¹ãƒˆ (35ã‚»ãƒ«): ${result2.success ? 'æˆåŠŸ' : 'å¤±æ•—'}`, testResults,
                    result2.success ? 'success' : 'error');
                
                if (result2.success) {
                    log(`   - åˆ†å‰²æ•°: ${result2.partitionCount}`, testResults);
                    log(`   - å¹³å‡åˆ†å‰²ã‚µã‚¤ã‚º: ${result2.averagePartitionSize.toFixed(1)}ã‚»ãƒ«`, testResults);
                    log(`   - å‡¦ç†æ™‚é–“: ${result2.executionTime.toFixed(4)}ms`, testResults);
                } else {
                    log(`   - å¤±æ•—ç†ç”±: ${result2.reason}`, testResults, 'error');
                }
                
                if (!result2.success) {
                    log("âŒ partitionLargeConstraintSetBit() ãƒ†ã‚¹ãƒˆå¤±æ•—", testResults, 'error');
                    return false;
                }

                // ãƒ†ã‚¹ãƒˆ3: å°è¦æ¨¡ã‚»ãƒƒãƒˆæ‹’å¦ãƒ†ã‚¹ãƒˆ
                const smallSet = createLargeConstraintSet(10, 2);
                const result3 = bitCSP.partitionLargeConstraintSetBit(smallSet);
                
                log(`${!result3.success ? 'âœ…' : 'âŒ'} å°è¦æ¨¡ã‚»ãƒƒãƒˆæ‹’å¦ãƒ†ã‚¹ãƒˆ (10ã‚»ãƒ«): ${!result3.success ? 'æ­£å¸¸æ‹’å¦' : 'ã‚¨ãƒ©ãƒ¼'}`, testResults,
                    !result3.success ? 'success' : 'error');

                log("âœ… partitionLargeConstraintSetBit() å…¨ãƒ†ã‚¹ãƒˆæˆåŠŸ", testResults, 'success');
                return true;

            } catch (error) {
                log(`âŒ partitionLargeConstraintSetBit() ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, testResults, 'error');
                return false;
            }
        }

        // 2. applyHeuristicPruningBit() ãƒ†ã‚¹ãƒˆ
        function testApplyHeuristicPruning() {
            log("=== applyHeuristicPruningBit() ãƒ†ã‚¹ãƒˆé–‹å§‹ ===", testResults, 'info');
            
            if (!bitCSP) {
                log("âŒ bitCSP ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚", testResults, 'error');
                return false;
            }
            
            try {
                // ãƒ†ã‚¹ãƒˆç”¨ã®æ¢ç´¢ç©ºé–“ã‚’ä½œæˆ
                const createSearchSpace = (configCount) => {
                    const configurations = [];
                    
                    for (let i = 0; i < configCount; i++) {
                        configurations.push({
                            id: i,
                            cells: [{ row: 0, col: 0 }, { row: 0, col: 1 }],
                            mineCount: i % 2,
                            feasibilityScore: Math.random(),
                            probability: Math.random()
                        });
                    }
                    
                    return {
                        configurations: configurations,
                        constraints: [
                            { cells: [{ row: 0, col: 0 }, { row: 0, col: 1 }], count: 1 }
                        ],
                        probabilityThreshold: 0.1
                    };
                };

                // ãƒ†ã‚¹ãƒˆ1: åŸºæœ¬çš„ãªæåˆˆã‚Šå‡¦ç†
                const searchSpace = createSearchSpace(100);
                const result1 = bitCSP.applyHeuristicPruningBit(searchSpace);
                
                log(`${result1.success ? 'âœ…' : 'âŒ'} åŸºæœ¬æåˆˆã‚Šãƒ†ã‚¹ãƒˆ (100è¨­å®š): ${result1.success ? 'æˆåŠŸ' : 'å¤±æ•—'}`, testResults,
                    result1.success ? 'success' : 'error');
                
                if (result1.success) {
                    log(`   - å…ƒè¨­å®šæ•°: ${result1.pruning.originalCount}`, testResults);
                    log(`   - ç”Ÿå­˜è¨­å®šæ•°: ${result1.finalConfigCount}`, testResults);
                    log(`   - åœ§ç¸®ç‡: ${(result1.compressionRatio * 100).toFixed(1)}%`, testResults);
                    log(`   - å®Ÿè¡Œæ™‚é–“: ${result1.executionTime.toFixed(4)}ms`, testResults);
                    log(`   - æåˆˆã‚Šçµ±è¨ˆ:`, testResults);
                    log(`     æ”¯é…ã«ã‚ˆã‚‹å‰Šé™¤: ${result1.pruning.pruningStats.dominated}`, testResults);
                    log(`     å®Ÿè¡Œä¸å¯èƒ½: ${result1.pruning.pruningStats.infeasible}`, testResults);
                    log(`     ä½ç¢ºç‡: ${result1.pruning.pruningStats.lowProbability}`, testResults);
                    log(`     å†—é•·: ${result1.pruning.pruningStats.redundant}`, testResults);
                } else {
                    log(`   - å¤±æ•—ç†ç”±: ${result1.reason}`, testResults, 'error');
                    if (result1.error) log(`   - ã‚¨ãƒ©ãƒ¼: ${result1.error}`, testResults, 'error');
                }
                
                if (!result1.success) {
                    log("âŒ applyHeuristicPruningBit() ãƒ†ã‚¹ãƒˆå¤±æ•—", testResults, 'error');
                    return false;
                }

                // ãƒ†ã‚¹ãƒˆ2: å¤§è¦æ¨¡æ¢ç´¢ç©ºé–“ã§ã®æåˆˆã‚Š
                const largeSearchSpace = createSearchSpace(1000);
                const result2 = bitCSP.applyHeuristicPruningBit(largeSearchSpace);
                
                log(`${result2.success ? 'âœ…' : 'âŒ'} å¤§è¦æ¨¡æåˆˆã‚Šãƒ†ã‚¹ãƒˆ (1000è¨­å®š): ${result2.success ? 'æˆåŠŸ' : 'å¤±æ•—'}`, testResults,
                    result2.success ? 'success' : 'error');
                
                if (result2.success) {
                    log(`   - åœ§ç¸®ç‡: ${(result2.compressionRatio * 100).toFixed(1)}%`, testResults);
                    log(`   - å‡¦ç†æ™‚é–“: ${result2.executionTime.toFixed(4)}ms`, testResults);
                }

                log("âœ… applyHeuristicPruningBit() å…¨ãƒ†ã‚¹ãƒˆæˆåŠŸ", testResults, 'success');
                return true;

            } catch (error) {
                log(`âŒ applyHeuristicPruningBit() ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, testResults, 'error');
                return false;
            }
        }

        // 3. optimizeSearchOrderBit() ãƒ†ã‚¹ãƒˆ
        function testOptimizeSearchOrder() {
            log("=== optimizeSearchOrderBit() ãƒ†ã‚¹ãƒˆé–‹å§‹ ===", testResults, 'info');
            
            if (!bitCSP) {
                log("âŒ bitCSP ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚", testResults, 'error');
                return false;
            }
            
            try {
                // ãƒ†ã‚¹ãƒˆåˆ¶ç´„ã‚»ãƒƒãƒˆã®ä½œæˆ
                const constraintSet = {
                    constraints: [
                        { cells: [{ row: 0, col: 0 }, { row: 0, col: 1 }], count: 1 },
                        { cells: [{ row: 0, col: 1 }, { row: 1, col: 1 }], count: 0 },
                        { cells: [{ row: 1, col: 0 }, { row: 1, col: 1 }, { row: 2, col: 1 }], count: 2 },
                        { cells: [{ row: 0, col: 2 }, { row: 1, col: 2 }], count: 1 }
                    ]
                };

                // ãƒ†ã‚¹ãƒˆ1: åŸºæœ¬çš„ãªé †åºæœ€é©åŒ–
                const result1 = bitCSP.optimizeSearchOrderBit(constraintSet);
                
                log(`${result1.success ? 'âœ…' : 'âŒ'} åŸºæœ¬é †åºæœ€é©åŒ–ãƒ†ã‚¹ãƒˆ: ${result1.success ? 'æˆåŠŸ' : 'å¤±æ•—'}`, testResults,
                    result1.success ? 'success' : 'error');
                
                if (result1.success) {
                    log(`   - ä¸¦ã³æ›¿ãˆåˆ¶ç´„æ•°: ${result1.reorderedConstraints}`, testResults);
                    log(`   - æœŸå¾…é«˜é€ŸåŒ–ç‡: ${result1.expectedSpeedup.toFixed(2)}x`, testResults);
                    log(`   - é †åºæˆ¦ç•¥: ${result1.optimization.orderingStrategy}`, testResults);
                    log(`   - å®Ÿè¡Œæ™‚é–“: ${result1.executionTime.toFixed(4)}ms`, testResults);
                    
                    // æœ€é©åŒ–é †åºã®è©³ç´°è¡¨ç¤º
                    log(`   - åˆ¶ç´„é †åºè©³ç´°:`, testResults);
                    for (let i = 0; i < Math.min(3, result1.optimization.orderingMetrics.length); i++) {
                        const metric = result1.optimization.orderingMetrics[i];
                        log(`     ${i + 1}ä½: ã‚»ãƒ«æ•°${metric.cellCount}, ã‚¿ã‚¤ãƒˆãƒã‚¹${metric.tightness.toFixed(3)}`, testResults);
                    }
                } else {
                    log(`   - å¤±æ•—ç†ç”±: ${result1.reason}`, testResults, 'error');
                }
                
                if (!result1.success) {
                    log("âŒ optimizeSearchOrderBit() ãƒ†ã‚¹ãƒˆå¤±æ•—", testResults, 'error');
                    return false;
                }

                // ãƒ†ã‚¹ãƒˆ2: ç©ºåˆ¶ç´„ã‚»ãƒƒãƒˆ
                const emptySet = { constraints: [] };
                const result2 = bitCSP.optimizeSearchOrderBit(emptySet);
                
                log(`${!result2.success ? 'âœ…' : 'âŒ'} ç©ºåˆ¶ç´„ã‚»ãƒƒãƒˆãƒ†ã‚¹ãƒˆ: ${!result2.success ? 'æ­£å¸¸æ‹’å¦' : 'ã‚¨ãƒ©ãƒ¼'}`, testResults,
                    !result2.success ? 'success' : 'error');

                log("âœ… optimizeSearchOrderBit() å…¨ãƒ†ã‚¹ãƒˆæˆåŠŸ", testResults, 'success');
                return true;

            } catch (error) {
                log(`âŒ optimizeSearchOrderBit() ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, testResults, 'error');
                return false;
            }
        }

        // 4. manageLargeSetMemoryBit() ãƒ†ã‚¹ãƒˆ
        function testManageLargeSetMemory() {
            log("=== manageLargeSetMemoryBit() ãƒ†ã‚¹ãƒˆé–‹å§‹ ===", testResults, 'info');
            
            if (!bitCSP) {
                log("âŒ bitCSP ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚", testResults, 'error');
                return false;
            }
            
            try {
                // ãƒ†ã‚¹ãƒˆ1: åŸºæœ¬ãƒ¡ãƒ¢ãƒªç®¡ç†
                const result1 = bitCSP.manageLargeSetMemoryBit(100); // 100MBé–¾å€¤
                
                log(`${result1.success ? 'âœ…' : 'âŒ'} åŸºæœ¬ãƒ¡ãƒ¢ãƒªç®¡ç†ãƒ†ã‚¹ãƒˆ: ${result1.success ? 'æˆåŠŸ' : 'å¤±æ•—'}`, testResults,
                    result1.success ? 'success' : 'error');
                
                if (result1.success) {
                    log(`   - åˆæœŸä½¿ç”¨é‡: ${result1.initialUsageMB.toFixed(2)}MB`, testResults);
                    log(`   - æœ€çµ‚ä½¿ç”¨é‡: ${result1.finalUsageMB.toFixed(2)}MB`, testResults);
                    log(`   - è§£æ”¾é‡: ${result1.memoryFreedMB.toFixed(2)}MB`, testResults);
                    log(`   - é–¾å€¤å†…: ${result1.withinThreshold ? 'ã¯ã„' : 'ã„ã„ãˆ'}`, testResults);
                    log(`   - å®Ÿè¡Œæ™‚é–“: ${result1.executionTime.toFixed(4)}ms`, testResults);
                    log(`   - æœ€é©åŒ–ã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ•°: ${result1.memory.optimizationActions.length}`, testResults);
                    
                    // æœ€é©åŒ–ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®è©³ç´°
                    for (const action of result1.memory.optimizationActions.slice(0, 3)) {
                        log(`     ${action}`, testResults);
                    }
                } else {
                    log(`   - å¤±æ•—ç†ç”±: ${result1.reason}`, testResults, 'error');
                    if (result1.error) log(`   - ã‚¨ãƒ©ãƒ¼: ${result1.error}`, testResults, 'error');
                }
                
                if (!result1.success) {
                    log("âŒ manageLargeSetMemoryBit() ãƒ†ã‚¹ãƒˆå¤±æ•—", testResults, 'error');
                    return false;
                }

                // ãƒ†ã‚¹ãƒˆ2: ä½ãƒ¡ãƒ¢ãƒªé–¾å€¤ã§ã®ç®¡ç†
                const result2 = bitCSP.manageLargeSetMemoryBit(10); // 10MBé–¾å€¤
                
                log(`${result2.success ? 'âœ…' : 'âŒ'} ä½ãƒ¡ãƒ¢ãƒªé–¾å€¤ãƒ†ã‚¹ãƒˆ (10MB): ${result2.success ? 'æˆåŠŸ' : 'å¤±æ•—'}`, testResults,
                    result2.success ? 'success' : 'error');
                
                if (result2.success) {
                    log(`   - è§£æ”¾é‡: ${result2.memoryFreedMB.toFixed(2)}MB`, testResults);
                    log(`   - æœ€é©åŒ–ã‚¢ã‚¯ã‚·ãƒ§ãƒ³æ•°: ${result2.memory.optimizationActions.length}`, testResults);
                }

                log("âœ… manageLargeSetMemoryBit() å…¨ãƒ†ã‚¹ãƒˆæˆåŠŸ", testResults, 'success');
                return true;

            } catch (error) {
                log(`âŒ manageLargeSetMemoryBit() ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, testResults, 'error');
                return false;
            }
        }

        // å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
        function runAllTests() {
            log("ğŸš€ Phase3-4 å…¨æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆé–‹å§‹", testResults, 'info');
            log("=" * 60, testResults);
            
            let allPassed = true;
            const tests = [
                { name: "partitionLargeConstraintSetBit()", func: testPartitionLargeConstraintSet },
                { name: "applyHeuristicPruningBit()", func: testApplyHeuristicPruning },
                { name: "optimizeSearchOrderBit()", func: testOptimizeSearchOrder },
                { name: "manageLargeSetMemoryBit()", func: testManageLargeSetMemory }
            ];

            for (const test of tests) {
                log(`\n--- ${test.name} ãƒ†ã‚¹ãƒˆ ---`, testResults, 'info');
                const passed = test.func();
                allPassed = allPassed && passed;
                log(`${test.name}: ${passed ? 'âœ… æˆåŠŸ' : 'âŒ å¤±æ•—'}`, testResults, passed ? 'success' : 'error');
            }

            log("\n" + "=" * 60, testResults);
            log(`ğŸ¯ Phase3-4 å…¨ãƒ†ã‚¹ãƒˆçµæœ: ${allPassed ? 'âœ… å…¨ã¦æˆåŠŸ' : 'âŒ ä¸€éƒ¨å¤±æ•—'}`, testResults, 
                allPassed ? 'success' : 'error');
            
            return allPassed;
        }

        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆé–¢æ•°ç¾¤ï¼ˆç°¡ç•¥ç‰ˆå®Ÿè£…ï¼‰
        function benchmarkLargeSetPartitioning() {
            log("âš¡ å¤§è¦æ¨¡ã‚»ãƒƒãƒˆåˆ†å‰²ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–‹å§‹", performanceResults, 'info');
            
            const results = [];
            for (let size = 16; size <= 40; size += 4) {
                const largeSet = createLargeConstraintSet(size, Math.floor(size / 5));
                
                const startTime = performance.now();
                const result = bitCSP.partitionLargeConstraintSetBit(largeSet);
                const endTime = performance.now();
                
                const executionTime = endTime - startTime;
                results.push({
                    size: size,
                    executionTime: executionTime,
                    partitionCount: result.success ? result.partitionCount : 0,
                    success: result.success
                });
                
                log(`${size}ã‚»ãƒ«: ${executionTime.toFixed(4)}ms (${result.success ? result.partitionCount + 'åˆ†å‰²' : 'å¤±æ•—'})`,
                    performanceResults, result.success ? 'success' : 'error');
            }
            
            const avgTime = results.filter(r => r.success).reduce((sum, r) => sum + r.executionTime, 0) / 
                           results.filter(r => r.success).length;
            
            updatePerformanceMetrics({
                'avg_partition_time': { value: avgTime.toFixed(4) + 'ms', label: 'å¹³å‡åˆ†å‰²æ™‚é–“' },
                'max_size_tested': { value: Math.max(...results.map(r => r.size)).toString(), label: 'æœ€å¤§ãƒ†ã‚¹ãƒˆã‚µã‚¤ã‚º' },
                'success_rate': { value: (results.filter(r => r.success).length / results.length * 100).toFixed(1) + '%', label: 'æˆåŠŸç‡' }
            });
        }

        function benchmarkHeuristicPruning() {
            log("âš¡ ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯æåˆˆã‚Šãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–‹å§‹", performanceResults, 'info');
            log("å®Ÿè£…äºˆå®š: æ§˜ã€…ãªè¨­å®šæ•°ã§ã®æåˆˆã‚Šæ€§èƒ½æ¸¬å®š", performanceResults, 'warning');
        }

        function benchmarkSearchOrderOptimization() {
            log("âš¡ æ¢ç´¢é †åºæœ€é©åŒ–ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–‹å§‹", performanceResults, 'info');
            log("å®Ÿè£…äºˆå®š: åˆ¶ç´„æ•°ã¨é«˜é€ŸåŒ–ç‡ã®é–¢ä¿‚æ¸¬å®š", performanceResults, 'warning');
        }

        function benchmarkMemoryManagement() {
            log("âš¡ ãƒ¡ãƒ¢ãƒªç®¡ç†ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–‹å§‹", performanceResults, 'info');
            log("å®Ÿè£…äºˆå®š: æ§˜ã€…ãªãƒ¡ãƒ¢ãƒªé–¾å€¤ã§ã®ç®¡ç†æ€§èƒ½æ¸¬å®š", performanceResults, 'warning');
        }

        function benchmarkExtremeScaleTest() {
            log("ğŸ”¥ æ¥µé™è¦æ¨¡ãƒ†ã‚¹ãƒˆ: 50ã‚»ãƒ«å‡¦ç†é–‹å§‹", performanceResults, 'info');
            log("âš ï¸ æ³¨æ„: ã“ã®å‡¦ç†ã«ã¯æ•°ç§’ã‹ã‹ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™", performanceResults, 'warning');
            
            const extremeSet = createLargeConstraintSet(50, 12);
            
            const startTime = performance.now();
            const result = bitCSP.partitionLargeConstraintSetBit(extremeSet);
            const endTime = performance.now();
            
            const totalTime = endTime - startTime;
            
            if (result.success) {
                log(`âœ… 50ã‚»ãƒ«æ¥µé™ãƒ†ã‚¹ãƒˆæˆåŠŸï¼`, performanceResults, 'success');
                log(`   - ç·å®Ÿè¡Œæ™‚é–“: ${totalTime.toFixed(2)}ms`, performanceResults);
                log(`   - åˆ†å‰²æ•°: ${result.partitionCount}`, performanceResults);
                log(`   - å¹³å‡åˆ†å‰²ã‚µã‚¤ã‚º: ${result.averagePartitionSize.toFixed(1)}ã‚»ãƒ«`, performanceResults);
                
                if (totalTime < 100) {
                    log(`ğŸ† å„ªç§€: 100msä»¥å†…ã§ã®50ã‚»ãƒ«å‡¦ç†é”æˆï¼`, performanceResults, 'success');
                } else if (totalTime < 500) {
                    log(`ğŸ¯ è‰¯å¥½: 500msä»¥å†…ã§ã®å‡¦ç†å®Œäº†`, performanceResults, 'success');
                } else {
                    log(`âš ï¸ é‡ã„å‡¦ç†: ${totalTime.toFixed(0)}ms`, performanceResults, 'warning');
                }
            } else {
                log(`âŒ 50ã‚»ãƒ«æ¥µé™ãƒ†ã‚¹ãƒˆå¤±æ•—: ${result.reason}`, performanceResults, 'error');
            }
        }

        // è©³ç´°ãƒ†ã‚¹ãƒˆé–¢æ•°ç¾¤ï¼ˆç°¡ç•¥ç‰ˆï¼‰
        function testComplexPartitioningScenarios() {
            log("ğŸ” è¤‡é›‘åˆ†å‰²ã‚·ãƒŠãƒªã‚ªãƒ†ã‚¹ãƒˆé–‹å§‹", detailedResults, 'info');
            log("å®Ÿè£…äºˆå®š: è¤‡é›‘ãªåˆ¶ç´„æ¥ç¶šãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã®åˆ†å‰²ãƒ†ã‚¹ãƒˆ", detailedResults, 'warning');
        }

        function testAdvancedPruningTechniques() {
            log("ğŸ” é«˜åº¦æåˆˆã‚ŠæŠ€æ³•ãƒ†ã‚¹ãƒˆé–‹å§‹", detailedResults, 'info');
            log("å®Ÿè£…äºˆå®š: æ”¯é…é–¢ä¿‚ãƒ»ç¢ºç‡é–¾å€¤ãƒ»å†—é•·æ€§ã®è©³ç´°ãƒ†ã‚¹ãƒˆ", detailedResults, 'warning');
        }

        function testAdaptiveOptimization() {
            log("ğŸ” é©å¿œçš„æœ€é©åŒ–ãƒ†ã‚¹ãƒˆé–‹å§‹", detailedResults, 'info');
            log("å®Ÿè£…äºˆå®š: å‹•çš„ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´ãƒ†ã‚¹ãƒˆ", detailedResults, 'warning');
        }

        // æœ€é©åŒ–ãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ãƒ¢
        function testOptimizationDemo() {
            log("ğŸª æœ€é©åŒ–ãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ãƒ¢é–‹å§‹", detailedResults, 'info');
            
            // ãƒ‡ãƒ¢ç”¨ã®åˆ¶ç´„ã‚»ãƒƒãƒˆã§å…¨å·¥ç¨‹ã‚’å®Ÿè¡Œ
            const demoSet = createLargeConstraintSet(25, 6);
            
            // 1. åˆ†å‰²å‡¦ç†
            const partitionResult = bitCSP.partitionLargeConstraintSetBit(demoSet);
            
            if (partitionResult.success) {
                let demoHTML = '<h3>ğŸ“Š æœ€é©åŒ–ãƒ—ãƒ­ã‚»ã‚¹çµæœ</h3>';
                demoHTML += `<p><strong>1. åˆ†å‰²å‡¦ç†:</strong> ${demoSet.cells.length}ã‚»ãƒ« â†’ ${partitionResult.partitionCount}åˆ†å‰²</p>`;
                demoHTML += `<p><strong>å¹³å‡åˆ†å‰²ã‚µã‚¤ã‚º:</strong> ${partitionResult.averagePartitionSize.toFixed(1)}ã‚»ãƒ«</p>`;
                
                // 2. ãƒ¡ãƒ¢ãƒªç®¡ç†
                const memoryResult = bitCSP.manageLargeSetMemoryBit(50);
                if (memoryResult.success) {
                    demoHTML += `<p><strong>2. ãƒ¡ãƒ¢ãƒªç®¡ç†:</strong> ${memoryResult.memoryFreedMB.toFixed(2)}MBè§£æ”¾</p>`;
                }
                
                // 3. åˆ¶ç´„æœ€é©åŒ–
                const constraintSet = { constraints: demoSet.constraints };
                const orderResult = bitCSP.optimizeSearchOrderBit(constraintSet);
                if (orderResult.success) {
                    demoHTML += `<p><strong>3. æ¢ç´¢é †åºæœ€é©åŒ–:</strong> ${orderResult.expectedSpeedup.toFixed(2)}xé«˜é€ŸåŒ–æœŸå¾…</p>`;
                }
                
                demoHTML += '<p><strong>ğŸ¯ æœ€é©åŒ–å®Œäº†:</strong> å¤§è¦æ¨¡ã‚»ãƒƒãƒˆå‡¦ç†æº–å‚™å®Œäº†</p>';
                
                optimizationDemo.innerHTML = demoHTML;
                log("âœ… æœ€é©åŒ–ãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ãƒ¢å®Œäº† - çµæœã¯ä¸‹ã®æœ€é©åŒ–çµæœè¡¨ç¤ºã‚’ç¢ºèªã—ã¦ãã ã•ã„", detailedResults, 'success');
            } else {
                log(`âŒ æœ€é©åŒ–ãƒ—ãƒ­ã‚»ã‚¹ãƒ‡ãƒ¢å¤±æ•—: ${partitionResult.reason}`, detailedResults, 'error');
            }
        }

        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¡¨ç¤º
        function updatePerformanceMetrics(metrics) {
            performanceMetrics.innerHTML = '';
            for (const [key, data] of Object.entries(metrics)) {
                const card = document.createElement('div');
                card.className = 'metric-card';
                card.innerHTML = `
                    <div class="metric-value">${data.value}</div>
                    <div class="metric-label">${data.label}</div>
                `;
                performanceMetrics.appendChild(card);
            }
        }
    </script>
</body>
</html>