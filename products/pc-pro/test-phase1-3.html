<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase1-3 Test</title>
</head>
<body>
    <h1>Phase1-3: å¢ƒç•Œã‚»ãƒ«æ¤œå‡ºã®å®Œå…¨ãƒ“ãƒƒãƒˆåŒ–ãƒ†ã‚¹ãƒˆ</h1>
    <div id="test-results"></div>
    <script src="../../core/minesweeper-core.js"></script>
    <script src="modules/bit-minesweeper.js"></script>
    <script src="modules/simple-bit-csp.js"></script>
    <script>
        function runPhase1_3Tests() {
            const results = [];
            
            try {
                // ãƒ†ã‚¹ãƒˆç”¨ã®ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ä½œæˆï¼ˆ6x6ã®ç›¤é¢ï¼‰
                const game = {
                    rows: 6,
                    cols: 6,
                    mineCount: 5,
                    board: [
                        [1, 1, 1, 0, 0, 0],
                        [1, -1, 2, 1, 0, 0], // -1ã¯åœ°é›·
                        [1, 1, 2, -1, 1, 0],
                        [0, 0, 1, 1, 1, 0],
                        [0, 0, 0, 0, 0, 0],
                        [0, 0, 0, 0, 0, 0]
                    ],
                    revealed: [
                        [true,  true,  false, false, false, false],
                        [true,  false, false, true,  false, false],
                        [true,  true,  true,  false, false, false],
                        [false, false, true,  true,  false, false],
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false]
                    ],
                    flagged: [
                        [false, false, false, false, false, false],
                        [false, true,  false, false, false, false], // (1,1)ã«æ——
                        [false, false, false, true,  false, false], // (2,3)ã«æ——
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false]
                    ]
                };
                
                const bitSystem = new BitMinesweeperSystem(6, 6);
                const csp = new SimpleBitCSP(game, bitSystem);
                
                results.push("âœ… ãƒ†ã‚¹ãƒˆç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æˆåŠŸ");
                
                // Test 1: å®Œå…¨ãƒ“ãƒƒãƒˆç‰ˆå¢ƒç•Œã‚»ãƒ«æ¤œå‡º
                const borderBits = new Uint32Array(csp.intsNeeded);
                csp.getBorderCellsBit(borderBits);
                const bitBorderCoords = csp.bitsToCoords(borderBits);
                
                // Phase1-2ã®çµæœã¨æ¯”è¼ƒ
                const hybridBorderCoords = csp.getBorderCellsHybrid();
                const traditionalBorderCoords = csp.getBorderCells();
                
                const sortCoords = (coords) => coords.sort((a, b) => a.row === b.row ? a.col - b.col : a.row - b.row);
                const bitSorted = sortCoords([...bitBorderCoords]);
                const hybridSorted = sortCoords([...hybridBorderCoords]);
                const traditionalSorted = sortCoords([...traditionalBorderCoords]);
                
                const bitVsHybridMatch = bitSorted.length === hybridSorted.length &&
                    bitSorted.every((coord, i) => 
                        coord.row === hybridSorted[i].row && coord.col === hybridSorted[i].col
                    );
                    
                const bitVsTraditionalMatch = bitSorted.length === traditionalSorted.length &&
                    bitSorted.every((coord, i) => 
                        coord.row === traditionalSorted[i].row && coord.col === traditionalSorted[i].col
                    );
                
                if (bitVsHybridMatch && bitVsTraditionalMatch) {
                    results.push("âœ… Test 1: å®Œå…¨ãƒ“ãƒƒãƒˆç‰ˆå¢ƒç•Œã‚»ãƒ«æ¤œå‡º - å…¨ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨ä¸€è‡´");
                } else {
                    results.push(`âŒ Test 1: å®Œå…¨ãƒ“ãƒƒãƒˆç‰ˆå¢ƒç•Œã‚»ãƒ«æ¤œå‡º - ä¸ä¸€è‡´ (bit:${bitSorted.length}, hybrid:${hybridSorted.length}, traditional:${traditionalSorted.length})`);
                    console.log('Bit version:', bitSorted);
                    console.log('Hybrid version:', hybridSorted);
                    console.log('Traditional version:', traditionalSorted);
                }
                
                // Test 2: ãƒ“ãƒƒãƒˆçµæœã‹ã‚‰å¾“æ¥å½¢å¼ã¸ã®å¤‰æ›ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ†ã‚¹ãƒˆ
                const helperBorderCoords = csp.getBorderCellsFromBits();
                const helperSorted = sortCoords([...helperBorderCoords]);
                
                const helperMatch = helperSorted.length === bitSorted.length &&
                    helperSorted.every((coord, i) => 
                        coord.row === bitSorted[i].row && coord.col === bitSorted[i].col
                    );
                
                if (helperMatch) {
                    results.push("âœ… Test 2: ãƒ“ãƒƒãƒˆâ†’å¾“æ¥å½¢å¼å¤‰æ›ãƒ˜ãƒ«ãƒ‘ãƒ¼ - æ­£å¸¸å‹•ä½œ");
                } else {
                    results.push("âŒ Test 2: ãƒ“ãƒƒãƒˆâ†’å¾“æ¥å½¢å¼å¤‰æ›ãƒ˜ãƒ«ãƒ‘ãƒ¼ - ç•°å¸¸");
                }
                
                // Test 3: çµ±åˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®ãƒ†ã‚¹ãƒˆ
                const unifiedBitCoords = csp.getBorderCellsUnified(true, true);
                const unifiedTraditionalCoords = csp.getBorderCellsUnified(false, true);
                const unifiedBitBits = csp.getBorderCellsUnified(true, false);
                
                const unifiedBitSorted = sortCoords([...unifiedBitCoords]);
                const unifiedTraditionalSorted = sortCoords([...unifiedTraditionalCoords]);
                const unifiedBitFromBits = sortCoords([...csp.bitsToCoords(unifiedBitBits)]);
                
                const unifiedMatch = unifiedBitSorted.length === unifiedTraditionalSorted.length &&
                    unifiedBitSorted.length === unifiedBitFromBits.length &&
                    unifiedBitSorted.every((coord, i) => 
                        coord.row === unifiedTraditionalSorted[i].row && coord.col === unifiedTraditionalSorted[i].col &&
                        coord.row === unifiedBitFromBits[i].row && coord.col === unifiedBitFromBits[i].col
                    );
                
                if (unifiedMatch) {
                    results.push("âœ… Test 3: çµ±åˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ - å…¨ãƒ¢ãƒ¼ãƒ‰ã§ä¸€è‡´");
                } else {
                    results.push("âŒ Test 3: çµ±åˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ - ä¸ä¸€è‡´");
                }
                
                // Test 4: ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ãƒ†ã‚¹ãƒˆï¼ˆä¸€æ™‚é…åˆ—ã®å‚ç…§ç¢ºèªï¼‰
                // ä¸€æ™‚é…åˆ—ãŒæ–°è¦ä½œæˆã§ã¯ãªãã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®tempBitsã‚’å‚ç…§ã—ã¦ã„ã‚‹ã‹ã‚’ãƒã‚§ãƒƒã‚¯
                let usesInstanceTempBits = false;
                
                // getBorderCellsBitå†…éƒ¨ã§ä¸€æ™‚é…åˆ—å‚ç…§ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã€ä¸€æ™‚çš„ã«é…åˆ—ã«è­˜åˆ¥å­ã‚’è¨­å®š
                csp.tempBits1[0] = 0xAAAAAAAA; // è­˜åˆ¥ãƒ‘ã‚¿ãƒ¼ãƒ³
                csp.tempBits2[0] = 0xBBBBBBBB;
                csp.tempBits3[0] = 0xCCCCCCCC;
                
                // å®Ÿéš›ã®å‡¦ç†ã§ä¸Šæ›¸ãã•ã‚Œã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                csp.getBorderCellsBit(borderBits);
                
                // ä¸€æ™‚é…åˆ—ãŒå®Ÿéš›ã«ä½¿ç”¨ã•ã‚ŒãŸå ´åˆã€è­˜åˆ¥ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ä¸Šæ›¸ãã•ã‚Œã‚‹ã¯ãš
                // ï¼ˆgetUnknownCellsBit, getNumberCellsBit, clearBitsç­‰ã§ä¸Šæ›¸ãã•ã‚Œã‚‹ï¼‰
                const tempBits1Used = csp.tempBits1[0] !== 0xAAAAAAAA;
                const tempBits2Used = csp.tempBits2[0] !== 0xBBBBBBBB;
                
                // tempBits3ã¯æœ€å¾Œã«clearã•ã‚Œã‚‹ãŸã‚ã€0ã«ãªã£ã¦ã„ã‚‹ã¯ãš
                const tempBits3Used = true; // getNeighborCellsBitã§ä½¿ç”¨ã•ã‚Œã‚‹
                
                usesInstanceTempBits = tempBits1Used && tempBits2Used && tempBits3Used;
                
                if (usesInstanceTempBits) {
                    results.push("âœ… Test 4: ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ - ä¸€æ™‚é…åˆ—ãŒæ­£å¸¸ã«å†åˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹");
                } else {
                    results.push("âŒ Test 4: ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ - ä¸€æ™‚é…åˆ—ãŒä½¿ç”¨ã•ã‚Œã¦ã„ãªã„å¯èƒ½æ€§");
                    console.log('tempBits1[0]:', csp.tempBits1[0].toString(16), 'expected change from AAAAAAAA');
                    console.log('tempBits2[0]:', csp.tempBits2[0].toString(16), 'expected change from BBBBBBBB');
                }
                
                // Test 5: ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ï¼ˆå¢ƒç•Œã‚»ãƒ«ãŒãªã„å ´åˆï¼‰
                const emptyGame = {
                    rows: 3,
                    cols: 3,
                    mineCount: 0,
                    board: [[0, 0, 0], [0, 0, 0], [0, 0, 0]],
                    revealed: [[false, false, false], [false, false, false], [false, false, false]],
                    flagged: [[false, false, false], [false, false, false], [false, false, false]]
                };
                
                const emptyBitSystem = new BitMinesweeperSystem(3, 3);
                const emptyCSP = new SimpleBitCSP(emptyGame, emptyBitSystem);
                const emptyBorderBits = new Uint32Array(emptyCSP.intsNeeded);
                
                emptyCSP.getBorderCellsBit(emptyBorderBits);
                const emptyBorderCoords = emptyCSP.bitsToCoords(emptyBorderBits);
                
                if (emptyBorderCoords.length === 0) {
                    results.push("âœ… Test 5: ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ï¼ˆå¢ƒç•Œãªã—ï¼‰ - æ­£å¸¸å‹•ä½œ");
                } else {
                    results.push(`âŒ Test 5: ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ï¼ˆå¢ƒç•Œãªã—ï¼‰ - ç•°å¸¸ (count: ${emptyBorderCoords.length})`);
                }
                
                // Test 6: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
                const iterations = 200;
                
                const startBit = performance.now();
                for (let i = 0; i < iterations; i++) {
                    csp.getBorderCellsBit(borderBits);
                }
                const timeBit = performance.now() - startBit;
                
                const startHybrid = performance.now();
                for (let i = 0; i < iterations; i++) {
                    csp.getBorderCellsHybrid();
                }
                const timeHybrid = performance.now() - startHybrid;
                
                const startTraditional = performance.now();
                for (let i = 0; i < iterations; i++) {
                    csp.getBorderCells();
                }
                const timeTraditional = performance.now() - startTraditional;
                
                const bitImprovement = timeTraditional > 0 ? ((timeTraditional - timeBit) / timeTraditional * 100).toFixed(1) : "0.0";
                const hybridImprovement = timeTraditional > 0 ? ((timeTraditional - timeHybrid) / timeTraditional * 100).toFixed(1) : "0.0";
                
                results.push(`ğŸ“Š Test 6: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒ`);
                results.push(`   å®Œå…¨ãƒ“ãƒƒãƒˆç‰ˆ: ${timeBit.toFixed(2)}ms (æ”¹å–„ç‡: ${bitImprovement}%)`);
                results.push(`   ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ç‰ˆ: ${timeHybrid.toFixed(2)}ms (æ”¹å–„ç‡: ${hybridImprovement}%)`);
                results.push(`   å¾“æ¥ç‰ˆ: ${timeTraditional.toFixed(2)}ms`);
                
            } catch (error) {
                results.push(`âŒ ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ: ${error.message}`);
                console.error(error);
            }
            
            // çµæœè¡¨ç¤º
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = '<h2>ãƒ†ã‚¹ãƒˆçµæœ</h2>' + 
                results.map(result => `<p>${result}</p>`).join('');
            
            console.log('Phase1-3 ãƒ†ã‚¹ãƒˆçµæœ:', results);
            
            return results.filter(r => r.startsWith('âŒ')).length === 0;
        }
        
        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†å¾Œã«ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
        window.addEventListener('load', () => {
            setTimeout(runPhase1_3Tests, 100);
        });
    </script>
</body>
</html>