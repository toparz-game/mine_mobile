<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase1-4 Test</title>
</head>
<body>
    <h1>Phase1-4: åˆ¶ç´„ç”Ÿæˆã®éƒ¨åˆ†ãƒ“ãƒƒãƒˆåŒ–ãƒ†ã‚¹ãƒˆ</h1>
    <div id="test-results"></div>
    <script src="../../core/minesweeper-core.js"></script>
    <script src="modules/bit-minesweeper.js"></script>
    <script src="modules/simple-bit-csp.js"></script>
    <script>
        function runPhase1_4Tests() {
            const results = [];
            
            try {
                // ãƒ†ã‚¹ãƒˆç”¨ã®ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ä½œæˆ
                const game = {
                    rows: 5,
                    cols: 5,
                    mineCount: 5,
                    board: [
                        [1, 2, 2, 1, 0],
                        [1, -1, -1, 2, 1], // -1ã¯åœ°é›·
                        [1, 2, 3, -1, 1],
                        [0, 1, -1, 2, 1],
                        [0, 1, 1, 1, 0]
                    ],
                    revealed: [
                        [true,  true,  false, false, false],
                        [true,  false, false, false, false],
                        [true,  true,  true,  false, true ],
                        [false, true,  false, true,  true ],
                        [false, false, false, false, false]
                    ],
                    flagged: [
                        [false, false, false, false, false],
                        [false, true,  false, false, false], // (1,1)ã«æ——
                        [false, false, false, true,  false], // (2,3)ã«æ——
                        [false, false, true,  false, false], // (3,2)ã«æ——
                        [false, false, false, false, false]
                    ]
                };
                
                const bitSystem = new BitMinesweeperSystem(5, 5);
                const csp = new SimpleBitCSP(game, bitSystem);
                
                results.push("âœ… ãƒ†ã‚¹ãƒˆç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æˆåŠŸ");
                
                // Test 1: ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ç‰ˆåˆ¶ç´„ç”Ÿæˆã¨å¾“æ¥ç‰ˆã®æ¯”è¼ƒ
                const hybridConstraints = csp.generateConstraintsHybrid();
                const traditionalConstraints = csp.generateConstraints(csp.getBorderCells());
                
                // åˆ¶ç´„æ•°ã®æ¯”è¼ƒ
                if (hybridConstraints.length === traditionalConstraints.length) {
                    results.push(`âœ… Test 1a: åˆ¶ç´„æ•°ä¸€è‡´ (${hybridConstraints.length}å€‹)`);
                } else {
                    results.push(`âŒ Test 1a: åˆ¶ç´„æ•°ä¸ä¸€è‡´ (hybrid:${hybridConstraints.length}, traditional:${traditionalConstraints.length})`);
                }
                
                // åˆ¶ç´„å†…å®¹ã®è©³ç´°æ¯”è¼ƒ
                let constraintsMatch = true;
                const sortConstraints = (constraints) => {
                    return constraints.sort((a, b) => {
                        if (a.sourceCell.row !== b.sourceCell.row) return a.sourceCell.row - b.sourceCell.row;
                        if (a.sourceCell.col !== b.sourceCell.col) return a.sourceCell.col - b.sourceCell.col;
                        return a.expectedMines - b.expectedMines;
                    });
                };
                
                const hybridSorted = sortConstraints([...hybridConstraints]);
                const traditionalSorted = sortConstraints([...traditionalConstraints]);
                
                for (let i = 0; i < hybridSorted.length && i < traditionalSorted.length; i++) {
                    const h = hybridSorted[i];
                    const t = traditionalSorted[i];
                    
                    if (h.expectedMines !== t.expectedMines ||
                        h.sourceCell.row !== t.sourceCell.row ||
                        h.sourceCell.col !== t.sourceCell.col ||
                        h.cells.length !== t.cells.length) {
                        constraintsMatch = false;
                        break;
                    }
                    
                    // ã‚»ãƒ«é…åˆ—ã®æ¯”è¼ƒ
                    const sortCells = (cells) => cells.sort((a, b) => a.row === b.row ? a.col - b.col : a.row - b.row);
                    const hCellsSorted = sortCells([...h.cells]);
                    const tCellsSorted = sortCells([...t.cells]);
                    
                    for (let j = 0; j < hCellsSorted.length; j++) {
                        if (hCellsSorted[j].row !== tCellsSorted[j].row || 
                            hCellsSorted[j].col !== tCellsSorted[j].col) {
                            constraintsMatch = false;
                            break;
                        }
                    }
                    
                    if (!constraintsMatch) break;
                }
                
                if (constraintsMatch) {
                    results.push("âœ… Test 1b: åˆ¶ç´„å†…å®¹å®Œå…¨ä¸€è‡´");
                } else {
                    results.push("âŒ Test 1b: åˆ¶ç´„å†…å®¹ä¸ä¸€è‡´");
                    console.log('Hybrid constraints:', hybridSorted);
                    console.log('Traditional constraints:', traditionalSorted);
                }
                
                // Test 2: æ•°å­—ã‚»ãƒ«å‘¨è¾ºã®æœªé–‹ã‚»ãƒ«å–å¾—ãƒ†ã‚¹ãƒˆ
                const testRow = 2, testCol = 1; // board[2][1] = 2
                const hybridNeighbors = csp.getNumberCellNeighborsHybrid(testRow, testCol);
                
                // å¾“æ¥æ–¹å¼ã§ã®æœŸå¾…å€¤ã‚’è¨ˆç®—
                const expectedNeighbors = [];
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const newRow = testRow + dr;
                        const newCol = testCol + dc;
                        
                        if (newRow >= 0 && newRow < game.rows && 
                            newCol >= 0 && newCol < game.cols &&
                            !game.revealed[newRow][newCol] && 
                            !game.flagged[newRow][newCol]) {
                            expectedNeighbors.push({ row: newRow, col: newCol });
                        }
                    }
                }
                
                const sortCells = (cells) => cells.sort((a, b) => a.row === b.row ? a.col - b.col : a.row - b.row);
                const hybridSorted2 = sortCells([...hybridNeighbors]);
                const expectedSorted = sortCells([...expectedNeighbors]);
                
                const neighborsMatch = hybridSorted2.length === expectedSorted.length &&
                    hybridSorted2.every((cell, i) => 
                        cell.row === expectedSorted[i].row && cell.col === expectedSorted[i].col
                    );
                
                if (neighborsMatch) {
                    results.push(`âœ… Test 2: æ•°å­—ã‚»ãƒ«å‘¨è¾ºå–å¾— - æ­£å¸¸å‹•ä½œ (${hybridNeighbors.length}å€‹)`);
                } else {
                    results.push(`âŒ Test 2: æ•°å­—ã‚»ãƒ«å‘¨è¾ºå–å¾— - ç•°å¸¸ (hybrid:${hybridNeighbors.length}, expected:${expectedNeighbors.length})`);
                }
                
                // Test 3: çµ±åˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®ãƒ†ã‚¹ãƒˆ
                const unifiedHybrid = csp.generateConstraintsUnified(null, true);
                const unifiedTraditional = csp.generateConstraintsUnified(null, false);
                
                const unifiedMatch = unifiedHybrid.length === unifiedTraditional.length &&
                    unifiedHybrid.length === hybridConstraints.length;
                
                if (unifiedMatch) {
                    results.push("âœ… Test 3: çµ±åˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ - æ­£å¸¸å‹•ä½œ");
                } else {
                    results.push("âŒ Test 3: çµ±åˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ - ç•°å¸¸");
                }
                
                // Test 4: ã‚«ã‚¹ã‚¿ãƒ ã‚»ãƒ«ãƒªã‚¹ãƒˆã§ã®åˆ¶ç´„ç”Ÿæˆãƒ†ã‚¹ãƒˆ
                const customCells = [
                    { row: 0, col: 2 },
                    { row: 0, col: 3 },
                    { row: 1, col: 2 }
                ];
                
                const hybridCustom = csp.generateConstraintsHybrid(customCells);
                const traditionalCustom = csp.generateConstraints(customCells);
                
                const customMatch = hybridCustom.length === traditionalCustom.length;
                
                if (customMatch) {
                    results.push(`âœ… Test 4: ã‚«ã‚¹ã‚¿ãƒ ã‚»ãƒ«ãƒªã‚¹ãƒˆ - æ­£å¸¸å‹•ä½œ (${hybridCustom.length}å€‹ã®åˆ¶ç´„)`);
                } else {
                    results.push(`âŒ Test 4: ã‚«ã‚¹ã‚¿ãƒ ã‚»ãƒ«ãƒªã‚¹ãƒˆ - ç•°å¸¸ (hybrid:${hybridCustom.length}, traditional:${traditionalCustom.length})`);
                }
                
                // Test 5: ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ï¼ˆåˆ¶ç´„ãŒç”Ÿæˆã•ã‚Œãªã„å ´åˆï¼‰
                const emptyGame = {
                    rows: 3,
                    cols: 3,
                    mineCount: 0,
                    board: [[0, 0, 0], [0, 0, 0], [0, 0, 0]],
                    revealed: [[true, true, true], [true, true, true], [true, true, true]],
                    flagged: [[false, false, false], [false, false, false], [false, false, false]]
                };
                
                const emptyBitSystem = new BitMinesweeperSystem(3, 3);
                const emptyCSP = new SimpleBitCSP(emptyGame, emptyBitSystem);
                const emptyConstraints = emptyCSP.generateConstraintsHybrid();
                
                if (emptyConstraints.length === 0) {
                    results.push("âœ… Test 5: ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ï¼ˆåˆ¶ç´„ãªã—ï¼‰ - æ­£å¸¸å‹•ä½œ");
                } else {
                    results.push(`âŒ Test 5: ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ï¼ˆåˆ¶ç´„ãªã—ï¼‰ - ç•°å¸¸ (count: ${emptyConstraints.length})`);
                }
                
                // Test 6: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
                const iterations = 150;
                
                const startHybrid = performance.now();
                for (let i = 0; i < iterations; i++) {
                    csp.generateConstraintsHybrid();
                }
                const timeHybrid = performance.now() - startHybrid;
                
                const startTraditional = performance.now();
                for (let i = 0; i < iterations; i++) {
                    csp.generateConstraints(csp.getBorderCells());
                }
                const timeTraditional = performance.now() - startTraditional;
                
                const improvement = timeTraditional > 0 ? ((timeTraditional - timeHybrid) / timeTraditional * 100).toFixed(1) : "0.0";
                
                results.push(`ğŸ“Š Test 6: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒ`);
                results.push(`   ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ç‰ˆ: ${timeHybrid.toFixed(2)}ms (æ”¹å–„ç‡: ${improvement}%)`);
                results.push(`   å¾“æ¥ç‰ˆ: ${timeTraditional.toFixed(2)}ms`);
                
            } catch (error) {
                results.push(`âŒ ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ: ${error.message}`);
                console.error(error);
            }
            
            // çµæœè¡¨ç¤º
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = '<h2>ãƒ†ã‚¹ãƒˆçµæœ</h2>' + 
                results.map(result => `<p>${result}</p>`).join('');
            
            console.log('Phase1-4 ãƒ†ã‚¹ãƒˆçµæœ:', results);
            
            return results.filter(r => r.startsWith('âŒ')).length === 0;
        }
        
        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†å¾Œã«ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
        window.addEventListener('load', () => {
            setTimeout(runPhase1_4Tests, 100);
        });
    </script>
</body>
</html>