<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase1-2 Test</title>
</head>
<body>
    <h1>Phase1-2: å¢ƒç•Œã‚»ãƒ«æ¤œå‡ºã®éƒ¨åˆ†ãƒ“ãƒƒãƒˆåŒ–ãƒ†ã‚¹ãƒˆ</h1>
    <div id="test-results"></div>
    <script src="../../core/minesweeper-core.js"></script>
    <script src="modules/bit-minesweeper.js"></script>
    <script src="modules/simple-bit-csp.js"></script>
    <script>
        function runPhase1_2Tests() {
            const results = [];
            
            try {
                // ãƒ†ã‚¹ãƒˆç”¨ã®ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ä½œæˆï¼ˆ5x5ã®å°ã•ãªç›¤é¢ï¼‰
                const game = {
                    rows: 5,
                    cols: 5,
                    mineCount: 3,
                    board: [
                        [0, 1, 1, 1, 0],
                        [0, 1, -1, 1, 0], // -1ã¯åœ°é›·
                        [0, 1, 1, 1, 0],
                        [0, 0, 0, 0, 0],
                        [0, 0, 0, 0, 0]
                    ],
                    revealed: [
                        [true,  true,  false, false, false],
                        [true,  true,  false, false, false],
                        [true,  true,  true,  false, false],
                        [false, false, false, false, false],
                        [false, false, false, false, false]
                    ],
                    flagged: [
                        [false, false, false, false, false],
                        [false, false, true,  false, false], // (1,2)ã«æ——
                        [false, false, false, false, false],
                        [false, false, false, false, false],
                        [false, false, false, false, false]
                    ]
                };
                
                const bitSystem = new BitMinesweeperSystem(5, 5);
                const csp = new SimpleBitCSP(game, bitSystem);
                
                results.push("âœ… ãƒ†ã‚¹ãƒˆç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æˆåŠŸ");
                
                // Test 1: æœªé–‹ã‚»ãƒ«ãƒ“ãƒƒãƒˆãƒãƒƒãƒ—ãƒ†ã‚¹ãƒˆ
                const unknownBits = new Uint32Array(csp.intsNeeded);
                csp.getUnknownCellsBit(unknownBits);
                const unknownCoords = csp.bitsToCoords(unknownBits);
                
                // æœŸå¾…å€¤ï¼šé–‹ç¤ºã•ã‚Œã¦ãŠã‚‰ãšæ——ã‚‚ç«‹ã£ã¦ã„ãªã„ã‚»ãƒ«
                // (0,2), (0,3), (0,4), (1,3), (1,4), (2,3), (2,4), (3,0)-(4,4)
                const expectedUnknownCount = 3 + 2 + 2 + 5 + 5; // 17å€‹
                
                if (unknownCoords.length === expectedUnknownCount) {
                    results.push("âœ… Test 1: æœªé–‹ã‚»ãƒ«ãƒ“ãƒƒãƒˆãƒãƒƒãƒ— - æ­£å¸¸å‹•ä½œ");
                } else {
                    results.push(`âŒ Test 1: æœªé–‹ã‚»ãƒ«ãƒ“ãƒƒãƒˆãƒãƒƒãƒ— - ç•°å¸¸ (count: ${unknownCoords.length}, expected: ${expectedUnknownCount})`);
                }
                
                // Test 2: é–‹ç¤ºæ¸ˆã¿ã‚»ãƒ«ãƒ“ãƒƒãƒˆãƒãƒƒãƒ—ãƒ†ã‚¹ãƒˆ
                const revealedBits = new Uint32Array(csp.intsNeeded);
                csp.getRevealedCellsBit(revealedBits);
                const revealedCoords = csp.bitsToCoords(revealedBits);
                
                const expectedRevealedCount = 7; // (0,0), (0,1), (1,0), (1,1), (2,0), (2,1), (2,2)
                
                if (revealedCoords.length === expectedRevealedCount) {
                    results.push("âœ… Test 2: é–‹ç¤ºæ¸ˆã¿ã‚»ãƒ«ãƒ“ãƒƒãƒˆãƒãƒƒãƒ— - æ­£å¸¸å‹•ä½œ");
                } else {
                    results.push(`âŒ Test 2: é–‹ç¤ºæ¸ˆã¿ã‚»ãƒ«ãƒ“ãƒƒãƒˆãƒãƒƒãƒ— - ç•°å¸¸ (count: ${revealedCoords.length}, expected: ${expectedRevealedCount})`);
                    console.log('Revealed coords:', revealedCoords);
                }
                
                // Test 3: æ•°å­—ã‚»ãƒ«ãƒ“ãƒƒãƒˆãƒãƒƒãƒ—ãƒ†ã‚¹ãƒˆ
                const numberBits = new Uint32Array(csp.intsNeeded);
                csp.getNumberCellsBit(numberBits);
                const numberCoords = csp.bitsToCoords(numberBits);
                
                // æœŸå¾…å€¤ï¼šé–‹ç¤ºæ¸ˆã¿ã§åœ°é›·æ•°>0ã®ã‚»ãƒ«
                // (0,1), (1,0), (1,1), (2,0), (2,1), (2,2) - ãŸã ã—(0,0)ã¯0ãªã®ã§å«ã¾ã‚Œãªã„
                const expectedNumberCount = 4;
                
                if (numberCoords.length === expectedNumberCount) {
                    results.push("âœ… Test 3: æ•°å­—ã‚»ãƒ«ãƒ“ãƒƒãƒˆãƒãƒƒãƒ— - æ­£å¸¸å‹•ä½œ");
                } else {
                    results.push(`âŒ Test 3: æ•°å­—ã‚»ãƒ«ãƒ“ãƒƒãƒˆãƒãƒƒãƒ— - ç•°å¸¸ (count: ${numberCoords.length}, expected: ${expectedNumberCount})`);
                    console.log('Number coords:', numberCoords);
                    // ãƒ‡ãƒãƒƒã‚°: å„ã‚»ãƒ«ã®å€¤ã‚’ç¢ºèª
                    for (let r = 0; r < 3; r++) {
                        for (let c = 0; c < 3; c++) {
                            if (game.revealed[r][c]) {
                                console.log(`Cell (${r},${c}): revealed=${game.revealed[r][c]}, value=${game.board[r][c]}`);
                            }
                        }
                    }
                }
                
                // Test 4: æ——ã‚»ãƒ«ãƒ“ãƒƒãƒˆãƒãƒƒãƒ—ãƒ†ã‚¹ãƒˆ
                const flaggedBits = new Uint32Array(csp.intsNeeded);
                csp.getFlaggedCellsBit(flaggedBits);
                const flaggedCoords = csp.bitsToCoords(flaggedBits);
                
                if (flaggedCoords.length === 1 && flaggedCoords[0].row === 1 && flaggedCoords[0].col === 2) {
                    results.push("âœ… Test 4: æ——ã‚»ãƒ«ãƒ“ãƒƒãƒˆãƒãƒƒãƒ— - æ­£å¸¸å‹•ä½œ");
                } else {
                    results.push(`âŒ Test 4: æ——ã‚»ãƒ«ãƒ“ãƒƒãƒˆãƒãƒƒãƒ— - ç•°å¸¸ (count: ${flaggedCoords.length})`);
                }
                
                // Test 5: ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å¢ƒç•Œã‚»ãƒ«æ¤œå‡ºã¨å¾“æ¥ç‰ˆã®æ¯”è¼ƒ
                const hybridBorderCells = csp.getBorderCellsHybrid();
                const traditionalBorderCells = csp.getBorderCells();
                
                // çµæœã‚’åº§æ¨™ã§ã‚½ãƒ¼ãƒˆã—ã¦æ¯”è¼ƒ
                const sortCoords = (coords) => coords.sort((a, b) => a.row === b.row ? a.col - b.col : a.row - b.row);
                const hybridSorted = sortCoords([...hybridBorderCells]);
                const traditionalSorted = sortCoords([...traditionalBorderCells]);
                
                const borderMatch = hybridSorted.length === traditionalSorted.length &&
                    hybridSorted.every((coord, i) => 
                        coord.row === traditionalSorted[i].row && coord.col === traditionalSorted[i].col
                    );
                
                if (borderMatch) {
                    results.push("âœ… Test 5: ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å¢ƒç•Œã‚»ãƒ«æ¤œå‡º - å¾“æ¥ç‰ˆã¨ä¸€è‡´");
                } else {
                    results.push(`âŒ Test 5: ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å¢ƒç•Œã‚»ãƒ«æ¤œå‡º - å¾“æ¥ç‰ˆã¨ä¸ä¸€è‡´ (hybrid: ${hybridSorted.length}, traditional: ${traditionalSorted.length})`);
                    console.log('Hybrid:', hybridSorted);
                    console.log('Traditional:', traditionalSorted);
                }
                
                // Test 6: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆï¼ˆç°¡æ˜“ç‰ˆï¼‰
                const iterations = 100;
                
                const startHybrid = performance.now();
                for (let i = 0; i < iterations; i++) {
                    csp.getBorderCellsHybrid();
                }
                const timeHybrid = performance.now() - startHybrid;
                
                const startTraditional = performance.now();
                for (let i = 0; i < iterations; i++) {
                    csp.getBorderCells();
                }
                const timeTraditional = performance.now() - startTraditional;
                
                const improvement = timeTraditional > 0 ? ((timeTraditional - timeHybrid) / timeTraditional * 100).toFixed(1) : "0.0";
                results.push(`ğŸ“Š Test 6: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒ - ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ç‰ˆ: ${timeHybrid.toFixed(2)}ms, å¾“æ¥ç‰ˆ: ${timeTraditional.toFixed(2)}ms (æ”¹å–„ç‡: ${improvement}%)`);
                
            } catch (error) {
                results.push(`âŒ ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ: ${error.message}`);
                console.error(error);
            }
            
            // çµæœè¡¨ç¤º
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = '<h2>ãƒ†ã‚¹ãƒˆçµæœ</h2>' + 
                results.map(result => `<p>${result}</p>`).join('');
            
            console.log('Phase1-2 ãƒ†ã‚¹ãƒˆçµæœ:', results);
            
            return results.filter(r => r.startsWith('âŒ')).length === 0;
        }
        
        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†å¾Œã«ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
        window.addEventListener('load', () => {
            setTimeout(runPhase1_2Tests, 100);
        });
    </script>
</body>
</html>