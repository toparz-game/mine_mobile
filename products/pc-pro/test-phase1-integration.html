<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase1 Integration Test</title>
    <style>
        body { font-family: monospace; margin: 20px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ccc; }
        .success { color: green; }
        .error { color: red; }
        .info { color: blue; }
        .performance { background-color: #f0f0f0; padding: 10px; }
    </style>
</head>
<body>
    <h1>Phase1 çµ±åˆãƒ†ã‚¹ãƒˆ: åŸºç›¤æ©Ÿèƒ½ã®ãƒ“ãƒƒãƒˆåŒ–å®Œå…¨å‹•ä½œç¢ºèª</h1>
    <div id="test-results"></div>
    
    <script src="../../core/minesweeper-core.js"></script>
    <script src="modules/bit-minesweeper.js"></script>
    <script src="modules/simple-bit-csp.js"></script>
    <script>
        function runPhase1IntegrationTests() {
            const results = [];
            let testsPassed = 0;
            let testsTotal = 0;
            
            function addResult(result, category = 'test') {
                results.push({text: result, category});
                if (category === 'test') {
                    testsTotal++;
                    if (result.startsWith('âœ…')) testsPassed++;
                }
            }
            
            try {
                addResult("=== Phase1 çµ±åˆãƒ†ã‚¹ãƒˆé–‹å§‹ ===", 'header');
                
                // è¤‡é›‘ãªãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã‚’ä½œæˆï¼ˆå®Ÿéš›ã®ã‚²ãƒ¼ãƒ çŠ¶æ³ã‚’æ¨¡æ“¬ï¼‰
                const game = {
                    rows: 8,
                    cols: 8,
                    mineCount: 12,
                    board: [
                        [1, 1, 0, 0, 1, 1, 1, 0],
                        [1, -1, 1, 1, 2, -1, 1, 0], // -1ã¯åœ°é›·
                        [2, 2, 2, 1, -1, 2, 2, 1],
                        [1, -1, 1, 1, 1, 1, 1, -1],
                        [1, 1, 1, 0, 0, 1, 2, 2],
                        [0, 0, 0, 1, 1, 2, -1, -1],
                        [1, 1, 1, 2, -1, 3, 3, 3],
                        [1, -1, 1, 2, 1, 2, -1, 1]
                    ],
                    revealed: [
                        [true,  true,  true,  true,  false, false, false, false],
                        [true,  false, true,  true,  false, false, true,  true ],
                        [false, true,  true,  true,  false, true,  true,  false],
                        [true,  false, true,  true,  true,  true,  true,  false],
                        [true,  true,  true,  true,  true,  false, false, false],
                        [true,  true,  true,  false, false, false, false, false],
                        [false, false, false, false, false, false, false, false],
                        [false, false, false, false, false, false, false, false]
                    ],
                    flagged: [
                        [false, false, false, false, false, false, false, false],
                        [false, true,  false, false, false, true,  false, false], // (1,1), (1,5)ã«æ——
                        [false, false, false, false, true,  false, false, false], // (2,4)ã«æ——
                        [false, true,  false, false, false, false, false, true ], // (3,1), (3,7)ã«æ——
                        [false, false, false, false, false, false, false, false],
                        [false, false, false, false, false, false, false, false],
                        [false, false, false, false, false, false, false, false],
                        [false, false, false, false, false, false, false, false]
                    ]
                };
                
                const bitSystem = new BitMinesweeperSystem(8, 8);
                const csp = new SimpleBitCSP(game, bitSystem);
                
                addResult("âœ… è¤‡é›‘ãªãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ç’°å¢ƒæ§‹ç¯‰å®Œäº†");
                
                // === ã‚»ã‚¯ã‚·ãƒ§ãƒ³1: Phase1-1æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ ===
                addResult("=== Phase1-1: ãƒ“ãƒƒãƒˆæ“ä½œåŸºç›¤ãƒ†ã‚¹ãƒˆ ===", 'section');
                
                // éš£æ¥ã‚»ãƒ«å–å¾—ãƒ†ã‚¹ãƒˆ
                const testBits = new Uint32Array(csp.intsNeeded);
                const resultBits = new Uint32Array(csp.intsNeeded);
                
                csp.setBit(testBits, 3, 3, true);
                csp.setBit(testBits, 4, 4, true);
                csp.getNeighborCellsBit(3, 3, testBits, resultBits);
                
                const neighborCount = csp.countNeighborsBit(3, 3, testBits);
                addResult(neighborCount === 1 ? "âœ… éš£æ¥ã‚»ãƒ«å–å¾—ãƒ»ã‚«ã‚¦ãƒ³ãƒˆæ©Ÿèƒ½" : "âŒ éš£æ¥ã‚»ãƒ«å–å¾—ãƒ»ã‚«ã‚¦ãƒ³ãƒˆæ©Ÿèƒ½");
                
                // ãƒ“ãƒƒãƒˆæ¼”ç®—ãƒ†ã‚¹ãƒˆ
                const bits1 = new Uint32Array(csp.intsNeeded);
                const bits2 = new Uint32Array(csp.intsNeeded);
                const bitsResult = new Uint32Array(csp.intsNeeded);
                
                csp.setBit(bits1, 2, 2, true);
                csp.setBit(bits2, 2, 2, true);
                csp.setBit(bits2, 2, 3, true);
                
                csp.andBits(bits1, bits2, bitsResult);
                const andCorrect = csp.getBit(bitsResult, 2, 2) && !csp.getBit(bitsResult, 2, 3);
                addResult(andCorrect ? "âœ… ãƒ“ãƒƒãƒˆæ¼”ç®—æ©Ÿèƒ½" : "âŒ ãƒ“ãƒƒãƒˆæ¼”ç®—æ©Ÿèƒ½");
                
                // === ã‚»ã‚¯ã‚·ãƒ§ãƒ³2: Phase1-2æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ ===
                addResult("=== Phase1-2: å¢ƒç•Œã‚»ãƒ«æ¤œå‡ºéƒ¨åˆ†ãƒ“ãƒƒãƒˆåŒ–ãƒ†ã‚¹ãƒˆ ===", 'section');
                
                const unknownBits = new Uint32Array(csp.intsNeeded);
                const revealedBits = new Uint32Array(csp.intsNeeded);
                const numberBits = new Uint32Array(csp.intsNeeded);
                
                csp.getUnknownCellsBit(unknownBits);
                csp.getRevealedCellsBit(revealedBits);
                csp.getNumberCellsBit(numberBits);
                
                const unknownCount = csp.popCountBits(unknownBits);
                const revealedCount = csp.popCountBits(revealedBits);
                const numberCount = csp.popCountBits(numberBits);
                
                addResult(`ğŸ“Š ã‚»ãƒ«åˆ†é¡: æœªé–‹${unknownCount}å€‹, é–‹ç¤ºæ¸ˆ${revealedCount}å€‹, æ•°å­—${numberCount}å€‹`, 'info');
                
                const hybridBorder = csp.getBorderCellsHybrid();
                const traditionalBorder = csp.getBorderCells();
                const borderMatch = hybridBorder.length === traditionalBorder.length;
                
                addResult(borderMatch ? "âœ… ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å¢ƒç•Œã‚»ãƒ«æ¤œå‡º" : "âŒ ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å¢ƒç•Œã‚»ãƒ«æ¤œå‡º");
                
                // === ã‚»ã‚¯ã‚·ãƒ§ãƒ³3: Phase1-3æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ ===
                addResult("=== Phase1-3: å¢ƒç•Œã‚»ãƒ«æ¤œå‡ºå®Œå…¨ãƒ“ãƒƒãƒˆåŒ–ãƒ†ã‚¹ãƒˆ ===", 'section');
                
                const borderBits = new Uint32Array(csp.intsNeeded);
                csp.getBorderCellsBit(borderBits);
                const bitBorderCoords = csp.bitsToCoords(borderBits);
                
                const fullBitMatch = bitBorderCoords.length === hybridBorder.length;
                addResult(fullBitMatch ? "âœ… å®Œå…¨ãƒ“ãƒƒãƒˆç‰ˆå¢ƒç•Œã‚»ãƒ«æ¤œå‡º" : "âŒ å®Œå…¨ãƒ“ãƒƒãƒˆç‰ˆå¢ƒç•Œã‚»ãƒ«æ¤œå‡º");
                
                const unifiedBorder = csp.getBorderCellsUnified(true, true);
                const unifiedMatch = unifiedBorder.length === bitBorderCoords.length;
                addResult(unifiedMatch ? "âœ… å¢ƒç•Œã‚»ãƒ«æ¤œå‡ºçµ±åˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹" : "âŒ å¢ƒç•Œã‚»ãƒ«æ¤œå‡ºçµ±åˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹");
                
                // === ã‚»ã‚¯ã‚·ãƒ§ãƒ³4: Phase1-4æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ ===
                addResult("=== Phase1-4: åˆ¶ç´„ç”Ÿæˆéƒ¨åˆ†ãƒ“ãƒƒãƒˆåŒ–ãƒ†ã‚¹ãƒˆ ===", 'section');
                
                const hybridConstraints = csp.generateConstraintsHybrid();
                const traditionalConstraints = csp.generateConstraints(csp.getBorderCells());
                const constraintMatch = hybridConstraints.length === traditionalConstraints.length;
                
                addResult(constraintMatch ? "âœ… ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰åˆ¶ç´„ç”Ÿæˆ" : "âŒ ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰åˆ¶ç´„ç”Ÿæˆ");
                addResult(`ğŸ“Š åˆ¶ç´„æ•°: ${hybridConstraints.length}å€‹`, 'info');
                
                // === ã‚»ã‚¯ã‚·ãƒ§ãƒ³5: Phase1-5æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ ===
                addResult("=== Phase1-5: åˆ¶ç´„ç”Ÿæˆå®Œå…¨ãƒ“ãƒƒãƒˆåŒ–ãƒ†ã‚¹ãƒˆ ===", 'section');
                
                const bitConstraints = csp.generateConstraintsBit();
                const convertedConstraints = csp.bitConstraintsToTraditional(bitConstraints);
                const fullConstraintMatch = convertedConstraints.length === traditionalConstraints.length;
                
                addResult(fullConstraintMatch ? "âœ… å®Œå…¨ãƒ“ãƒƒãƒˆç‰ˆåˆ¶ç´„ç”Ÿæˆ" : "âŒ å®Œå…¨ãƒ“ãƒƒãƒˆç‰ˆåˆ¶ç´„ç”Ÿæˆ");
                
                const constraintStats = csp.getBitConstraintsStats(bitConstraints);
                addResult(`ğŸ“Š åˆ¶ç´„çµ±è¨ˆ: å¹³å‡${constraintStats.avgCellsPerConstraint.toFixed(1)}ã‚»ãƒ«/åˆ¶ç´„, åœ°é›·ç·æ•°${constraintStats.totalExpectedMines}`, 'info');
                
                const advancedConstraints = csp.generateConstraintsAdvanced(null, 'bit', 'traditional');
                const advancedMatch = advancedConstraints.length === traditionalConstraints.length;
                addResult(advancedMatch ? "âœ… åˆ¶ç´„ç”Ÿæˆæœ€çµ‚çµ±åˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹" : "âŒ åˆ¶ç´„ç”Ÿæˆæœ€çµ‚çµ±åˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹");
                
                // === ã‚»ã‚¯ã‚·ãƒ§ãƒ³6: çµ±åˆå‹•ä½œãƒ†ã‚¹ãƒˆ ===
                addResult("=== Phase1çµ±åˆå‹•ä½œãƒ†ã‚¹ãƒˆ ===", 'section');
                
                // å…¨æ©Ÿèƒ½ã‚’çµ„ã¿åˆã‚ã›ãŸå‹•ä½œãƒ†ã‚¹ãƒˆ
                try {
                    // 1. ãƒ“ãƒƒãƒˆç‰ˆå¢ƒç•Œã‚»ãƒ«æ¤œå‡º
                    const integrationBorderBits = new Uint32Array(csp.intsNeeded);
                    csp.getBorderCellsBit(integrationBorderBits);
                    
                    // 2. ãƒ“ãƒƒãƒˆç‰ˆåˆ¶ç´„ç”Ÿæˆï¼ˆå¢ƒç•Œã‚»ãƒ«ã‚’æŒ‡å®šï¼‰
                    const integrationConstraints = csp.generateConstraintsBit(integrationBorderBits);
                    
                    // 3. çµ±è¨ˆæƒ…å ±å–å¾—
                    const integrationStats = csp.getBitConstraintsStats(integrationConstraints);
                    
                    // 4. å¾“æ¥å½¢å¼ã¸ã®å¤‰æ›
                    const integrationTraditional = csp.bitConstraintsToTraditional(integrationConstraints);
                    
                    // 5. é€†å¤‰æ›ãƒ†ã‚¹ãƒˆ
                    const integrationBackToBit = csp.traditionalConstraintsToBit(integrationTraditional);
                    
                    addResult("âœ… Phase1çµ±åˆå‹•ä½œãƒã‚§ãƒ¼ãƒ³å®Ÿè¡Œå®Œäº†");
                    addResult(`ğŸ“Š çµ±åˆçµæœ: ${integrationStats.constraintCount}åˆ¶ç´„, ${integrationStats.totalCells}ã‚»ãƒ«å‡¦ç†`, 'info');
                    
                } catch (integrationError) {
                    addResult(`âŒ Phase1çµ±åˆå‹•ä½œã‚¨ãƒ©ãƒ¼: ${integrationError.message}`);
                }
                
                // === ã‚»ã‚¯ã‚·ãƒ§ãƒ³7: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç·åˆæ¯”è¼ƒ ===
                addResult("=== Phase1ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç·åˆè©•ä¾¡ ===", 'section');
                
                const perfIterations = 100;
                
                // å¢ƒç•Œã‚»ãƒ«æ¤œå‡ºãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹
                const borderPerf = {
                    traditional: 0,
                    hybrid: 0,
                    bit: 0
                };
                
                let start = performance.now();
                for (let i = 0; i < perfIterations; i++) csp.getBorderCells();
                borderPerf.traditional = performance.now() - start;
                
                start = performance.now();
                for (let i = 0; i < perfIterations; i++) csp.getBorderCellsHybrid();
                borderPerf.hybrid = performance.now() - start;
                
                start = performance.now();
                for (let i = 0; i < perfIterations; i++) {
                    const tempBits = new Uint32Array(csp.intsNeeded);
                    csp.getBorderCellsBit(tempBits);
                }
                borderPerf.bit = performance.now() - start;
                
                // åˆ¶ç´„ç”Ÿæˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹
                const constraintPerf = {
                    traditional: 0,
                    hybrid: 0,
                    bit: 0
                };
                
                start = performance.now();
                for (let i = 0; i < perfIterations; i++) csp.generateConstraints(csp.getBorderCells());
                constraintPerf.traditional = performance.now() - start;
                
                start = performance.now();
                for (let i = 0; i < perfIterations; i++) csp.generateConstraintsHybrid();
                constraintPerf.hybrid = performance.now() - start;
                
                start = performance.now();
                for (let i = 0; i < perfIterations; i++) csp.generateConstraintsBit();
                constraintPerf.bit = performance.now() - start;
                
                // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµæœè¡¨ç¤º
                addResult(`ğŸ“Š å¢ƒç•Œã‚»ãƒ«æ¤œå‡ºãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ (${perfIterations}å›):`, 'performance');
                addResult(`   å¾“æ¥ç‰ˆ: ${borderPerf.traditional.toFixed(2)}ms`, 'performance');
                addResult(`   ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ç‰ˆ: ${borderPerf.hybrid.toFixed(2)}ms (æ”¹å–„ç‡: ${((borderPerf.traditional - borderPerf.hybrid) / borderPerf.traditional * 100).toFixed(1)}%)`, 'performance');
                addResult(`   å®Œå…¨ãƒ“ãƒƒãƒˆç‰ˆ: ${borderPerf.bit.toFixed(2)}ms (æ”¹å–„ç‡: ${((borderPerf.traditional - borderPerf.bit) / borderPerf.traditional * 100).toFixed(1)}%)`, 'performance');
                
                addResult(`ğŸ“Š åˆ¶ç´„ç”Ÿæˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ (${perfIterations}å›):`, 'performance');
                addResult(`   å¾“æ¥ç‰ˆ: ${constraintPerf.traditional.toFixed(2)}ms`, 'performance');
                addResult(`   ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ç‰ˆ: ${constraintPerf.hybrid.toFixed(2)}ms (æ”¹å–„ç‡: ${((constraintPerf.traditional - constraintPerf.hybrid) / constraintPerf.traditional * 100).toFixed(1)}%)`, 'performance');
                addResult(`   å®Œå…¨ãƒ“ãƒƒãƒˆç‰ˆ: ${constraintPerf.bit.toFixed(2)}ms (æ”¹å–„ç‡: ${((constraintPerf.traditional - constraintPerf.bit) / constraintPerf.traditional * 100).toFixed(1)}%)`, 'performance');
                
                // === ã‚»ã‚¯ã‚·ãƒ§ãƒ³8: Phase2æº–å‚™çŠ¶æ³ãƒã‚§ãƒƒã‚¯ ===
                addResult("=== Phase2æº–å‚™çŠ¶æ³ãƒã‚§ãƒƒã‚¯ ===", 'section');
                
                // Phase2ã§å¿…è¦ã«ãªã‚‹åŸºç›¤æ©Ÿèƒ½ãŒæƒã£ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                const phase2ReadyChecks = [
                    () => typeof csp.getBorderCellsBit === 'function',
                    () => typeof csp.generateConstraintsBit === 'function',
                    () => typeof csp.bitConstraintsToTraditional === 'function',
                    () => typeof csp.andBits === 'function',
                    () => typeof csp.orBits === 'function',
                    () => typeof csp.debugPrintBits === 'function'
                ];
                
                const phase2Ready = phase2ReadyChecks.every(check => check());
                addResult(phase2Ready ? "âœ… Phase2æº–å‚™å®Œäº† - å¿…è¦åŸºç›¤æ©Ÿèƒ½ã™ã¹ã¦å®Ÿè£…æ¸ˆã¿" : "âŒ Phase2æº–å‚™ä¸å®Œå…¨");
                
            } catch (error) {
                addResult(`âŒ çµ±åˆãƒ†ã‚¹ãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ: ${error.message}`);
                console.error('Integration test error:', error);
            }
            
            // === æœ€çµ‚çµæœ ===
            addResult("=== Phase1çµ±åˆãƒ†ã‚¹ãƒˆçµæœ ===", 'header');
            addResult(`ãƒ†ã‚¹ãƒˆå®Ÿè¡Œçµæœ: ${testsPassed}/${testsTotal} æˆåŠŸ`, testsPassed === testsTotal ? 'success' : 'error');
            
            if (testsPassed === testsTotal) {
                addResult("ğŸ‰ Phase1å®Œå…¨æˆåŠŸï¼Phase2å®Ÿè£…æº–å‚™å®Œäº†", 'success');
            } else {
                addResult("âš ï¸ ä¸€éƒ¨ãƒ†ã‚¹ãƒˆå¤±æ•—ã€‚ä¿®æ­£ãŒå¿…è¦ã§ã™ã€‚", 'error');
            }
            
            // çµæœè¡¨ç¤º
            displayResults(results);
            
            return testsPassed === testsTotal;
        }
        
        function displayResults(results) {
            const resultsDiv = document.getElementById('test-results');
            let html = '';
            
            for (const result of results) {
                let className = '';
                switch (result.category) {
                    case 'header':
                        html += `<h2>${result.text}</h2>`;
                        continue;
                    case 'section':
                        html += `<h3>${result.text}</h3>`;
                        continue;
                    case 'success':
                        className = 'success';
                        break;
                    case 'error':
                        className = 'error';
                        break;
                    case 'info':
                        className = 'info';
                        break;
                    case 'performance':
                        className = 'performance';
                        break;
                }
                
                html += `<p class="${className}">${result.text}</p>`;
            }
            
            resultsDiv.innerHTML = html;
        }
        
        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†å¾Œã«ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
        window.addEventListener('load', () => {
            setTimeout(runPhase1IntegrationTests, 100);
        });
    </script>
</body>
</html>