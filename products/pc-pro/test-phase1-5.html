<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase1-5 Test</title>
</head>
<body>
    <h1>Phase1-5: åˆ¶ç´„ç”Ÿæˆã®å®Œå…¨ãƒ“ãƒƒãƒˆåŒ–ãƒ†ã‚¹ãƒˆ</h1>
    <div id="test-results"></div>
    <script src="../../core/minesweeper-core.js"></script>
    <script src="modules/bit-minesweeper.js"></script>
    <script src="modules/simple-bit-csp.js"></script>
    <script>
        function runPhase1_5Tests() {
            const results = [];
            
            try {
                // ãƒ†ã‚¹ãƒˆç”¨ã®ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ä½œæˆï¼ˆè¤‡é›‘ãªåˆ¶ç´„ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
                const game = {
                    rows: 6,
                    cols: 6,
                    mineCount: 8,
                    board: [
                        [1, 2, -1, 2, 1, 0],
                        [1, -1, 3, -1, 2, 1], // -1ã¯åœ°é›·
                        [2, 2, -1, 3, 3, -1],
                        [1, -1, 2, 2, -1, 2],
                        [1, 1, 1, 1, 1, 1],
                        [0, 0, 0, 0, 0, 0]
                    ],
                    revealed: [
                        [true,  true,  false, false, true,  false],
                        [true,  false, true,  false, false, true ],
                        [false, true,  false, true,  true,  false],
                        [true,  false, false, true,  false, true ],
                        [false, false, true,  false, false, false],
                        [false, false, false, false, false, false]
                    ],
                    flagged: [
                        [false, false, true,  false, false, false], // (0,2)ã«æ——
                        [false, true,  false, true,  false, false], // (1,1), (1,3)ã«æ——
                        [false, false, true,  false, false, true ], // (2,2), (2,5)ã«æ——
                        [false, true,  false, false, true,  false], // (3,1), (3,4)ã«æ——
                        [false, false, false, false, false, false],
                        [false, false, false, false, false, false]
                    ]
                };
                
                const bitSystem = new BitMinesweeperSystem(6, 6);
                const csp = new SimpleBitCSP(game, bitSystem);
                
                results.push("âœ… ãƒ†ã‚¹ãƒˆç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—æˆåŠŸ");
                
                // Test 1: å®Œå…¨ãƒ“ãƒƒãƒˆç‰ˆåˆ¶ç´„ç”Ÿæˆ
                const bitConstraints = csp.generateConstraintsBit();
                const traditionalConstraints = csp.generateConstraints(csp.getBorderCells());
                const hybridConstraints = csp.generateConstraintsHybrid();
                
                results.push(`ğŸ“Š åˆ¶ç´„æ•°æ¯”è¼ƒ: Bit(${bitConstraints.length}) vs Hybrid(${hybridConstraints.length}) vs Traditional(${traditionalConstraints.length})`);
                
                // Test 2: ãƒ“ãƒƒãƒˆåˆ¶ç´„ã‹ã‚‰å¾“æ¥å½¢å¼ã¸ã®å¤‰æ›ãƒ†ã‚¹ãƒˆ
                const convertedConstraints = csp.bitConstraintsToTraditional(bitConstraints);
                
                // åˆ¶ç´„æ•°ã®ä¸€è‡´ç¢ºèª
                if (convertedConstraints.length === traditionalConstraints.length) {
                    results.push("âœ… Test 2a: å¤‰æ›å¾Œåˆ¶ç´„æ•°ä¸€è‡´");
                } else {
                    results.push(`âŒ Test 2a: å¤‰æ›å¾Œåˆ¶ç´„æ•°ä¸ä¸€è‡´ (converted:${convertedConstraints.length}, traditional:${traditionalConstraints.length})`);
                }
                
                // åˆ¶ç´„å†…å®¹ã®è©³ç´°æ¯”è¼ƒï¼ˆã‚½ãƒ¼ãƒˆå¾Œæ¯”è¼ƒï¼‰
                const sortConstraints = (constraints) => {
                    return constraints.sort((a, b) => {
                        if (a.sourceCell.row !== b.sourceCell.row) return a.sourceCell.row - b.sourceCell.row;
                        if (a.sourceCell.col !== b.sourceCell.col) return a.sourceCell.col - b.sourceCell.col;
                        return a.expectedMines - b.expectedMines;
                    });
                };
                
                const convertedSorted = sortConstraints([...convertedConstraints]);
                const traditionalSorted = sortConstraints([...traditionalConstraints]);
                
                let detailMatch = true;
                for (let i = 0; i < Math.min(convertedSorted.length, traditionalSorted.length); i++) {
                    const c = convertedSorted[i];
                    const t = traditionalSorted[i];
                    
                    if (c.expectedMines !== t.expectedMines ||
                        c.sourceCell.row !== t.sourceCell.row ||
                        c.sourceCell.col !== t.sourceCell.col ||
                        c.cells.length !== t.cells.length) {
                        detailMatch = false;
                        break;
                    }
                    
                    // ã‚»ãƒ«é…åˆ—ã®æ¯”è¼ƒ
                    const sortCells = (cells) => cells.sort((a, b) => a.row === b.row ? a.col - b.col : a.row - b.row);
                    const cCellsSorted = sortCells([...c.cells]);
                    const tCellsSorted = sortCells([...t.cells]);
                    
                    for (let j = 0; j < cCellsSorted.length; j++) {
                        if (cCellsSorted[j].row !== tCellsSorted[j].row || 
                            cCellsSorted[j].col !== tCellsSorted[j].col) {
                            detailMatch = false;
                            break;
                        }
                    }
                    
                    if (!detailMatch) break;
                }
                
                if (detailMatch) {
                    results.push("âœ… Test 2b: å¤‰æ›å¾Œåˆ¶ç´„å†…å®¹å®Œå…¨ä¸€è‡´");
                } else {
                    results.push("âŒ Test 2b: å¤‰æ›å¾Œåˆ¶ç´„å†…å®¹ä¸ä¸€è‡´");
                    console.log('Converted constraints:', convertedSorted.slice(0, 3));
                    console.log('Traditional constraints:', traditionalSorted.slice(0, 3));
                    
                    // è©³ç´°ãªå·®åˆ†ã‚’ç¢ºèª
                    for (let i = 0; i < Math.min(3, convertedSorted.length, traditionalSorted.length); i++) {
                        const c = convertedSorted[i];
                        const t = traditionalSorted[i];
                        console.log(`Constraint ${i}:`);
                        console.log(`  Converted: source(${c.sourceCell.row},${c.sourceCell.col}) mines:${c.expectedMines} cells:${c.cells.length}`);
                        console.log(`  Traditional: source(${t.sourceCell.row},${t.sourceCell.col}) mines:${t.expectedMines} cells:${t.cells.length}`);
                        if (c.cells.length === t.cells.length) {
                            const sortCells = (cells) => cells.sort((a, b) => a.row === b.row ? a.col - b.col : a.row - b.row);
                            const cCells = sortCells([...c.cells]);
                            const tCells = sortCells([...t.cells]);
                            console.log(`  Converted cells:`, cCells);
                            console.log(`  Traditional cells:`, tCells);
                        }
                    }
                }
                
                // Test 3: å¾“æ¥åˆ¶ç´„ã‹ã‚‰ãƒ“ãƒƒãƒˆåˆ¶ç´„ã¸ã®å¤‰æ›ãƒ†ã‚¹ãƒˆ
                const backConvertedBitConstraints = csp.traditionalConstraintsToBit(traditionalConstraints);
                const backConvertedTraditional = csp.bitConstraintsToTraditional(backConvertedBitConstraints);
                
                const backConvertMatch = backConvertedTraditional.length === traditionalConstraints.length;
                
                if (backConvertMatch) {
                    results.push("âœ… Test 3: åŒæ–¹å‘å¤‰æ›ãƒ†ã‚¹ãƒˆ - æ­£å¸¸å‹•ä½œ");
                } else {
                    results.push("âŒ Test 3: åŒæ–¹å‘å¤‰æ›ãƒ†ã‚¹ãƒˆ - ç•°å¸¸");
                }
                
                // Test 4: ãƒ“ãƒƒãƒˆåˆ¶ç´„çµ±è¨ˆæƒ…å ±ãƒ†ã‚¹ãƒˆ
                const stats = csp.getBitConstraintsStats(bitConstraints);
                
                const expectedTotalCells = convertedConstraints.reduce((sum, c) => sum + c.cells.length, 0);
                const expectedTotalMines = convertedConstraints.reduce((sum, c) => sum + c.expectedMines, 0);
                
                const statsMatch = stats.constraintCount === bitConstraints.length &&
                                 stats.totalCells === expectedTotalCells &&
                                 stats.totalExpectedMines === expectedTotalMines;
                
                if (statsMatch) {
                    results.push(`âœ… Test 4: çµ±è¨ˆæƒ…å ± - æ­£å¸¸å‹•ä½œ (åˆ¶ç´„:${stats.constraintCount}, ã‚»ãƒ«:${stats.totalCells}, åœ°é›·:${stats.totalExpectedMines})`);
                    results.push(`   å¹³å‡ã‚»ãƒ«æ•°/åˆ¶ç´„: ${stats.avgCellsPerConstraint.toFixed(1)}, æœ€å¤§:${stats.maxCellsPerConstraint}, æœ€å°:${stats.minCellsPerConstraint}`);
                } else {
                    results.push("âŒ Test 4: çµ±è¨ˆæƒ…å ± - ç•°å¸¸");
                }
                
                // Test 5: çµ±åˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆï¼ˆå…¨ãƒ¢ãƒ¼ãƒ‰ï¼‰
                const advancedTraditional = csp.generateConstraintsAdvanced(null, 'traditional', 'traditional');
                const advancedHybrid = csp.generateConstraintsAdvanced(null, 'hybrid', 'traditional');
                const advancedBit = csp.generateConstraintsAdvanced(null, 'bit', 'traditional');
                const advancedBitNative = csp.generateConstraintsAdvanced(null, 'bit', 'bit');
                
                const advancedMatch = advancedTraditional.length === advancedHybrid.length &&
                                    advancedHybrid.length === advancedBit.length &&
                                    advancedBitNative.length === bitConstraints.length;
                
                if (advancedMatch) {
                    results.push("âœ… Test 5: çµ±åˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼ˆå…¨ãƒ¢ãƒ¼ãƒ‰ï¼‰ - æ­£å¸¸å‹•ä½œ");
                } else {
                    results.push(`âŒ Test 5: çµ±åˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼ˆå…¨ãƒ¢ãƒ¼ãƒ‰ï¼‰ - ç•°å¸¸ (trad:${advancedTraditional.length}, hyb:${advancedHybrid.length}, bit:${advancedBit.length}, bitNative:${advancedBitNative.length})`);
                }
                
                // Test 6: ã‚«ã‚¹ã‚¿ãƒ ã‚»ãƒ«ãƒ“ãƒƒãƒˆã§ã®åˆ¶ç´„ç”Ÿæˆãƒ†ã‚¹ãƒˆ
                const customCells = [
                    { row: 0, col: 3 },
                    { row: 1, col: 2 },
                    { row: 2, col: 0 }
                ];
                
                const customCellsBits = new Uint32Array(csp.intsNeeded);
                csp.coordsToBits(customCells, customCellsBits);
                
                const customBitConstraints = csp.generateConstraintsBit(customCellsBits);
                const customTraditionalConstraints = csp.generateConstraints(customCells);
                
                const customMatch = customBitConstraints.length === customTraditionalConstraints.length;
                
                if (customMatch) {
                    results.push(`âœ… Test 6: ã‚«ã‚¹ã‚¿ãƒ ã‚»ãƒ«åˆ¶ç´„ç”Ÿæˆ - æ­£å¸¸å‹•ä½œ (${customBitConstraints.length}å€‹ã®åˆ¶ç´„)`);
                } else {
                    results.push(`âŒ Test 6: ã‚«ã‚¹ã‚¿ãƒ ã‚»ãƒ«åˆ¶ç´„ç”Ÿæˆ - ç•°å¸¸ (bit:${customBitConstraints.length}, traditional:${customTraditionalConstraints.length})`);
                }
                
                // Test 7: ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ï¼ˆç©ºã®åˆ¶ç´„ï¼‰
                const emptyGame = {
                    rows: 3,
                    cols: 3,
                    mineCount: 0,
                    board: [[0, 0, 0], [0, 0, 0], [0, 0, 0]],
                    revealed: [[true, true, true], [true, true, true], [true, true, true]],
                    flagged: [[false, false, false], [false, false, false], [false, false, false]]
                };
                
                const emptyBitSystem = new BitMinesweeperSystem(3, 3);
                const emptyCSP = new SimpleBitCSP(emptyGame, emptyBitSystem);
                const emptyBitConstraints = emptyCSP.generateConstraintsBit();
                
                if (emptyBitConstraints.length === 0) {
                    results.push("âœ… Test 7: ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ï¼ˆç©ºåˆ¶ç´„ï¼‰ - æ­£å¸¸å‹•ä½œ");
                } else {
                    results.push(`âŒ Test 7: ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ï¼ˆç©ºåˆ¶ç´„ï¼‰ - ç•°å¸¸ (count: ${emptyBitConstraints.length})`);
                }
                
                // Test 8: ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ãƒ†ã‚¹ãƒˆ
                const memoryTestIterations = 100;
                const startMemTest = performance.now();
                
                for (let i = 0; i < memoryTestIterations; i++) {
                    const testBitConstraints = csp.generateConstraintsBit();
                    // ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã‚’é˜²ããŸã‚å‚ç…§ã‚’å‰Šé™¤
                    testBitConstraints.length = 0;
                }
                
                const memTestTime = performance.now() - startMemTest;
                
                results.push(`ğŸ“Š Test 8: ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ãƒ†ã‚¹ãƒˆ - ${memoryTestIterations}å›å®Ÿè¡Œ: ${memTestTime.toFixed(2)}ms`);
                
                // Test 9: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒï¼ˆæœ€çµ‚ï¼‰
                const iterations = 200;
                
                const startBit = performance.now();
                for (let i = 0; i < iterations; i++) {
                    csp.generateConstraintsBit();
                }
                const timeBit = performance.now() - startBit;
                
                const startHybrid = performance.now();
                for (let i = 0; i < iterations; i++) {
                    csp.generateConstraintsHybrid();
                }
                const timeHybrid = performance.now() - startHybrid;
                
                const startTraditional = performance.now();
                for (let i = 0; i < iterations; i++) {
                    csp.generateConstraints(csp.getBorderCells());
                }
                const timeTraditional = performance.now() - startTraditional;
                
                const bitImprovement = timeTraditional > 0 ? ((timeTraditional - timeBit) / timeTraditional * 100).toFixed(1) : "0.0";
                const hybridImprovement = timeTraditional > 0 ? ((timeTraditional - timeHybrid) / timeTraditional * 100).toFixed(1) : "0.0";
                
                results.push(`ğŸ“Š Test 9: æœ€çµ‚ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒ (${iterations}å›å®Ÿè¡Œ)`);
                results.push(`   å®Œå…¨ãƒ“ãƒƒãƒˆç‰ˆ: ${timeBit.toFixed(2)}ms (æ”¹å–„ç‡: ${bitImprovement}%)`);
                results.push(`   ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ç‰ˆ: ${timeHybrid.toFixed(2)}ms (æ”¹å–„ç‡: ${hybridImprovement}%)`);
                results.push(`   å¾“æ¥ç‰ˆ: ${timeTraditional.toFixed(2)}ms`);
                
                // Test 10: çµ±åˆå‹•ä½œç¢ºèª
                try {
                    // å…¨æ©Ÿèƒ½ã‚’çµ„ã¿åˆã‚ã›ãŸå‹•ä½œãƒ†ã‚¹ãƒˆ
                    const borderBits = new Uint32Array(csp.intsNeeded);
                    csp.getBorderCellsBit(borderBits);
                    const finalBitConstraints = csp.generateConstraintsBit(borderBits);
                    const finalStats = csp.getBitConstraintsStats(finalBitConstraints);
                    
                    results.push(`âœ… Test 10: çµ±åˆå‹•ä½œç¢ºèª - æˆåŠŸ (å¢ƒç•Œ+åˆ¶ç´„+çµ±è¨ˆ: ${finalStats.constraintCount}å€‹ã®åˆ¶ç´„)`);
                } catch (integrationError) {
                    results.push(`âŒ Test 10: çµ±åˆå‹•ä½œç¢ºèª - ã‚¨ãƒ©ãƒ¼: ${integrationError.message}`);
                }
                
            } catch (error) {
                results.push(`âŒ ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ: ${error.message}`);
                console.error(error);
            }
            
            // çµæœè¡¨ç¤º
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = '<h2>ãƒ†ã‚¹ãƒˆçµæœ</h2>' + 
                results.map(result => `<p>${result}</p>`).join('');
            
            console.log('Phase1-5 ãƒ†ã‚¹ãƒˆçµæœ:', results);
            
            return results.filter(r => r.startsWith('âŒ')).length === 0;
        }
        
        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†å¾Œã«ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
        window.addEventListener('load', () => {
            setTimeout(runPhase1_5Tests, 100);
        });
    </script>
</body>
</html>