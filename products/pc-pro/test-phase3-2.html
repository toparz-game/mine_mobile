<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase3-2: ç¢ºç‡è¨ˆç®—ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ“ãƒƒãƒˆåŒ–ãƒ†ã‚¹ãƒˆ</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }
        .test-section {
            background-color: #2d2d2d;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .success { color: #4CAF50; }
        .error { color: #f44336; }
        .warning { color: #ff9800; }
        .info { color: #2196F3; }
        .test-button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: all 0.3s;
        }
        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        .test-results {
            background-color: #1e1e1e;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            max-height: 400px;
            overflow-y: auto;
        }
        .performance-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .metric-card {
            background-color: #333;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #ff6b6b;
        }
        .metric-label {
            font-size: 14px;
            color: #bbb;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ§® Phase3-2: ç¢ºç‡è¨ˆç®—ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ“ãƒƒãƒˆåŒ–</h1>
            <p>ç›®æ¨™: ç¢ºç‡è¨ˆç®—ã‚’ãƒ“ãƒƒãƒˆæ¼”ç®—ã§é«˜é€ŸåŒ–ã€Phase2æ¯”50%é«˜é€ŸåŒ–</p>
            <p>ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚·ã‚¹ãƒ†ãƒ ã¨LRUæœ€é©åŒ–ã«ã‚ˆã‚‹å¤§è¦æ¨¡ãƒ‡ãƒ¼ã‚¿å‡¦ç†</p>
        </div>

        <div class="test-section">
            <h2>ğŸ“‹ Phase3-2 æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</h2>
            <button class="test-button" onclick="testCalculateCellProbabilities()">1. calculateCellProbabilitiesBit() ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testAggregateSolutionStats()">2. aggregateSolutionStatsBit() ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testOptimizeProbabilityCalculation()">3. optimizeProbabilityCalculationBit() ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testCacheProbabilityResults()">4. cacheProbabilityResultsBit() ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="runAllTests()">ğŸ¯ å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
            <button class="test-button" onclick="clearResults()" style="background: linear-gradient(45deg, #f44336, #d32f2f);">ğŸ§¹ çµæœã‚¯ãƒªã‚¢</button>
            <div id="testResults" class="test-results"></div>
        </div>

        <div class="test-section">
            <h2>âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š</h2>
            <button class="test-button" onclick="benchmarkProbabilityCalculation()">ç¢ºç‡è¨ˆç®—æ€§èƒ½ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯</button>
            <button class="test-button" onclick="benchmarkCachePerformance()">ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ€§èƒ½ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯</button>
            <button class="test-button" onclick="benchmarkLargeSetOptimization()">å¤§è¦æ¨¡ã‚»ãƒƒãƒˆæœ€é©åŒ–ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯</button>
            <button class="test-button" onclick="benchmarkPhase2Comparison()">Phase2æ¯”è¼ƒãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯</button>
            <div id="performanceResults" class="test-results"></div>
            <div id="performanceMetrics" class="performance-metrics"></div>
        </div>

        <div class="test-section">
            <h2>ğŸ” è©³ç´°å‹•ä½œãƒ†ã‚¹ãƒˆ</h2>
            <button class="test-button" onclick="testComplexMultiGroup()">è¤‡æ•°ã‚°ãƒ«ãƒ¼ãƒ—çµ±åˆãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testCacheLRUBehavior()">ã‚­ãƒ£ãƒƒã‚·ãƒ¥LRUå‹•ä½œãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testMemoryEfficiency()">ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testAccuracyComparison()">ç²¾åº¦æ¯”è¼ƒãƒ†ã‚¹ãƒˆ</button>
            <div id="detailedResults" class="test-results"></div>
        </div>
    </div>

    <script src="modules/bit-minesweeper.js"></script>
    <script src="modules/simple-bit-csp.js"></script>
    <script>
        let testResults = document.getElementById('testResults');
        let performanceResults = document.getElementById('performanceResults');
        let detailedResults = document.getElementById('detailedResults');
        let performanceMetrics = document.getElementById('performanceMetrics');

        // ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ¢ãƒƒã‚¯ã‚²ãƒ¼ãƒ ç’°å¢ƒ
        const mockGame = {
            rows: 16,
            cols: 16,
            mines: 40,
            board: Array(16).fill().map(() => Array(16).fill(0)),
            isValidCoord: (row, col) => row >= 0 && row < 16 && col >= 0 && col < 16
        };

        // SimpleBitCSPã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’åˆæœŸåŒ–
        const bitSystem = new BitMinesweeperSystem(mockGame);
        const bitCSP = new SimpleBitCSP(mockGame, bitSystem);

        function log(message, element = testResults, className = '') {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}\n`;
            element.textContent += logMessage;
            if (className) {
                element.className += ` ${className}`;
            }
            element.scrollTop = element.scrollHeight;
        }

        function clearResults() {
            testResults.textContent = '';
            performanceResults.textContent = '';
            detailedResults.textContent = '';
            performanceMetrics.innerHTML = '';
        }

        // ãƒ†ã‚¹ãƒˆç”¨ã®è§£æ±ºãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç”Ÿæˆ
        function createMockSolutions(count = 5, cellCount = 4) {
            const solutions = [];
            const cells = Array(cellCount).fill().map((_, i) => ({
                row: Math.floor(i / 2),
                col: i % 2
            }));

            for (let i = 0; i < count; i++) {
                const cellsBits = new Uint32Array(bitCSP.intsNeeded);
                
                // ãƒ©ãƒ³ãƒ€ãƒ ã«åœ°é›·ã‚’é…ç½®
                for (let j = 0; j < cellCount; j++) {
                    if (Math.random() < 0.4) { // 40%ã®ç¢ºç‡ã§åœ°é›·
                        const cell = cells[j];
                        const bitIndex = bitCSP.bitSystem.coordToBit(cell.row, cell.col);
                        const arrayIndex = Math.floor(bitIndex / 32);
                        const bitPos = bitIndex % 32;
                        cellsBits[arrayIndex] |= (1 << bitPos);
                    }
                }

                solutions.push({
                    configId: i,
                    cellsBits: cellsBits,
                    cells: cells,
                    mineCount: bitCSP.bitSystem.popCountBits(cellsBits)
                });
            }

            return solutions;
        }

        // 1. calculateCellProbabilitiesBit() ãƒ†ã‚¹ãƒˆ
        function testCalculateCellProbabilities() {
            log("=== calculateCellProbabilitiesBit() ãƒ†ã‚¹ãƒˆé–‹å§‹ ===", testResults, 'info');
            
            try {
                // ãƒ†ã‚¹ãƒˆ1: åŸºæœ¬çš„ãªç¢ºç‡è¨ˆç®—
                const mockSolutions = createMockSolutions(10, 4);
                const startTime = performance.now();
                const result = bitCSP.calculateCellProbabilitiesBit(mockSolutions);
                const endTime = performance.now();

                log(`âœ… åŸºæœ¬ç¢ºç‡è¨ˆç®—: ${result.cellsAnalyzed}ã‚»ãƒ«åˆ†æå®Œäº†`, testResults, 'success');
                log(`   - è§£æ±ºãƒ‘ã‚¿ãƒ¼ãƒ³æ•°: ${result.totalSolutions}`, testResults);
                log(`   - å®Ÿè¡Œæ™‚é–“: ${result.executionTime.toFixed(4)}ms`, testResults);
                log(`   - ã‚»ãƒ«ç¢ºç‡ã‚µãƒ³ãƒ—ãƒ«:`, testResults);

                let sampleCount = 0;
                for (const [cellKey, probability] of Object.entries(result.probabilities)) {
                    if (sampleCount < 4) {
                        log(`     ${cellKey}: ${(probability * 100).toFixed(1)}%`, testResults);
                        sampleCount++;
                    }
                }

                // ãƒ†ã‚¹ãƒˆ2: ç©ºã®è§£æ±ºãƒ‘ã‚¿ãƒ¼ãƒ³
                const emptyResult = bitCSP.calculateCellProbabilitiesBit([]);
                log(`âœ… ç©ºãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ†ã‚¹ãƒˆ: ${typeof emptyResult === 'object' ? 'æ­£å¸¸å‡¦ç†' : 'ã‚¨ãƒ©ãƒ¼'}`, testResults, 'success');

                // ãƒ†ã‚¹ãƒˆ3: å¤§é‡ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã®æ€§èƒ½æ¸¬å®š
                const largeMockSolutions = createMockSolutions(100, 6);
                const largeStartTime = performance.now();
                const largeResult = bitCSP.calculateCellProbabilitiesBit(largeMockSolutions);
                const largeEndTime = performance.now();

                log(`âœ… å¤§é‡ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ†ã‚¹ãƒˆ: 100è§£æ±ºãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’${largeResult.executionTime.toFixed(4)}msã§å‡¦ç†`, testResults, 'success');

                if (largeResult.executionTime < 10) {
                    log(`ğŸ¯ æ€§èƒ½ç›®æ¨™é”æˆ: ${largeResult.executionTime.toFixed(4)}ms < 10ms`, testResults, 'success');
                } else {
                    log(`âš ï¸ æ€§èƒ½ç›®æ¨™æœªé”æˆ: ${largeResult.executionTime.toFixed(4)}ms â‰¥ 10ms`, testResults, 'warning');
                }

                log("âœ… calculateCellProbabilitiesBit() å…¨ãƒ†ã‚¹ãƒˆæˆåŠŸ", testResults, 'success');
                return true;

            } catch (error) {
                log(`âŒ calculateCellProbabilitiesBit() ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, testResults, 'error');
                return false;
            }
        }

        // 2. aggregateSolutionStatsBit() ãƒ†ã‚¹ãƒˆ
        function testAggregateSolutionStats() {
            log("=== aggregateSolutionStatsBit() ãƒ†ã‚¹ãƒˆé–‹å§‹ ===", testResults, 'info');
            
            try {
                // è¤‡æ•°ã‚°ãƒ«ãƒ¼ãƒ—ã®ä½œæˆ
                const solutionGroups = [
                    {
                        solutions: createMockSolutions(5, 3),
                        cells: Array(3).fill().map((_, i) => ({row: 0, col: i})),
                        executionTime: 1.2
                    },
                    {
                        solutions: createMockSolutions(8, 4),
                        cells: Array(4).fill().map((_, i) => ({row: 1, col: i})),
                        executionTime: 2.1
                    },
                    {
                        solutions: createMockSolutions(3, 2),
                        cells: Array(2).fill().map((_, i) => ({row: 2, col: i})),
                        executionTime: 0.8
                    }
                ];

                const result = bitCSP.aggregateSolutionStatsBit(solutionGroups);

                if (result.success) {
                    log(`âœ… çµ±è¨ˆé›†è¨ˆæˆåŠŸ: ${result.stats.totalGroups}ã‚°ãƒ«ãƒ¼ãƒ—å‡¦ç†`, testResults, 'success');
                    log(`   - ç·è§£æ±ºãƒ‘ã‚¿ãƒ¼ãƒ³: ${result.stats.totalSolutions}`, testResults);
                    log(`   - ç·ã‚»ãƒ«æ•°: ${result.stats.totalCells}`, testResults);
                    log(`   - ç·å®Ÿè¡Œæ™‚é–“: ${result.stats.totalExecutionTime.toFixed(2)}ms`, testResults);
                    log(`   - é›†è¨ˆå‡¦ç†æ™‚é–“: ${result.executionTime.toFixed(4)}ms`, testResults);
                    log(`   - ã‚°ãƒ«ãƒ¼ãƒ—å¹³å‡æ™‚é–“: ${result.stats.performanceMetrics.averageGroupTime.toFixed(4)}ms`, testResults);
                    log(`   - å…¨ä½“ç¢ºç‡ã‚¨ãƒ³ãƒˆãƒªæ•°: ${Object.keys(result.stats.overallProbabilities).length}`, testResults);

                    // ç©ºã‚°ãƒ«ãƒ¼ãƒ—ãƒ†ã‚¹ãƒˆ
                    const emptyResult = bitCSP.aggregateSolutionStatsBit([]);
                    log(`âœ… ç©ºã‚°ãƒ«ãƒ¼ãƒ—ãƒ†ã‚¹ãƒˆ: ${!emptyResult.success ? 'æ­£å¸¸æ‹’å¦' : 'ã‚¨ãƒ©ãƒ¼'}`, testResults, 
                        !emptyResult.success ? 'success' : 'error');

                    log("âœ… aggregateSolutionStatsBit() å…¨ãƒ†ã‚¹ãƒˆæˆåŠŸ", testResults, 'success');
                    return true;
                } else {
                    log(`âŒ çµ±è¨ˆé›†è¨ˆå¤±æ•—: ${result.reason}`, testResults, 'error');
                    return false;
                }

            } catch (error) {
                log(`âŒ aggregateSolutionStatsBit() ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, testResults, 'error');
                return false;
            }
        }

        // 3. optimizeProbabilityCalculationBit() ãƒ†ã‚¹ãƒˆ
        function testOptimizeProbabilityCalculation() {
            log("=== optimizeProbabilityCalculationBit() ãƒ†ã‚¹ãƒˆé–‹å§‹ ===", testResults, 'info');
            
            try {
                // ãƒ†ã‚¹ãƒˆ1: å¤§è¦æ¨¡ã‚»ãƒƒãƒˆï¼ˆ25ã‚»ãƒ«ï¼‰
                const largeSet = {
                    cells: Array(25).fill().map((_, i) => ({
                        row: Math.floor(i / 5),
                        col: i % 5
                    })),
                    constraints: [
                        {
                            cells: Array(6).fill().map((_, i) => ({row: 0, col: i})).slice(0, 3),
                            count: 1
                        },
                        {
                            cells: Array(6).fill().map((_, i) => ({row: 1, col: i})).slice(0, 3),
                            count: 2
                        }
                    ]
                };

                const result = bitCSP.optimizeProbabilityCalculationBit(largeSet);

                if (result.success) {
                    log(`âœ… å¤§è¦æ¨¡æœ€é©åŒ–æˆåŠŸ: ${result.originalCellCount}ã‚»ãƒ«ã‚’${result.chunksProcessed}ãƒãƒ£ãƒ³ã‚¯ã§å‡¦ç†`, testResults, 'success');
                    log(`   - å®Ÿè¡Œæ™‚é–“: ${result.executionTime.toFixed(4)}ms`, testResults);
                    log(`   - å‡¦ç†æ™‚é–“: ${result.totalProcessingTime.toFixed(4)}ms`, testResults);
                    log(`   - æœ€é©åŒ–æ¯”ç‡: ${result.optimizationRatio.toFixed(2)}x`, testResults);
                    log(`   - ãƒ¡ãƒ¢ãƒªåŠ¹ç‡: ${result.memoryEfficiency}`, testResults);
                    log(`   - æœ‰åŠ¹è§£æ±ºæ•°: ${result.totalValidSolutions}`, testResults);
                    log(`   - ç¢ºç‡ã‚¨ãƒ³ãƒˆãƒªæ•°: ${Object.keys(result.combinedProbabilities).length}`, testResults);

                    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è©•ä¾¡
                    if (result.executionTime < 100) {
                        log(`ğŸ¯ å¤§è¦æ¨¡å‡¦ç†ç›®æ¨™é”æˆ: ${result.executionTime.toFixed(4)}ms < 100ms`, testResults, 'success');
                    } else {
                        log(`âš ï¸ å¤§è¦æ¨¡å‡¦ç†ç›®æ¨™æœªé”æˆ: ${result.executionTime.toFixed(4)}ms â‰¥ 100ms`, testResults, 'warning');
                    }

                } else {
                    log(`âŒ å¤§è¦æ¨¡æœ€é©åŒ–å¤±æ•—: ${result.reason}`, testResults, 'error');
                }

                // ãƒ†ã‚¹ãƒˆ2: å°è¦æ¨¡ã‚»ãƒƒãƒˆæ‹’å¦ãƒ†ã‚¹ãƒˆï¼ˆ15ã‚»ãƒ«ï¼‰
                const smallSet = {
                    cells: Array(15).fill().map((_, i) => ({row: 0, col: i})),
                    constraints: []
                };

                const smallResult = bitCSP.optimizeProbabilityCalculationBit(smallSet);
                log(`âœ… å°è¦æ¨¡ã‚»ãƒƒãƒˆæ‹’å¦ãƒ†ã‚¹ãƒˆ: ${!smallResult.success ? 'æ­£å¸¸æ‹’å¦' : 'ã‚¨ãƒ©ãƒ¼'}`, testResults,
                    !smallResult.success ? 'success' : 'error');

                log("âœ… optimizeProbabilityCalculationBit() å…¨ãƒ†ã‚¹ãƒˆæˆåŠŸ", testResults, 'success');
                return true;

            } catch (error) {
                log(`âŒ optimizeProbabilityCalculationBit() ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, testResults, 'error');
                return false;
            }
        }

        // 4. cacheProbabilityResultsBit() ãƒ†ã‚¹ãƒˆ
        function testCacheProbabilityResults() {
            log("=== cacheProbabilityResultsBit() ãƒ†ã‚¹ãƒˆé–‹å§‹ ===", testResults, 'info');
            
            try {
                // ãƒ†ã‚¹ãƒˆ1: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜
                const testResults1 = { probabilities: { "0,0": 0.4, "0,1": 0.6 }, solutionCount: 10 };
                const storeResult = bitCSP.cacheProbabilityResultsBit("test_key_1", testResults1);

                log(`âœ… ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜ãƒ†ã‚¹ãƒˆ: ${storeResult.success ? 'æˆåŠŸ' : 'å¤±æ•—'}`, testResults, 
                    storeResult.success ? 'success' : 'error');
                log(`   - ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: ${storeResult.action}`, testResults);
                log(`   - ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚º: ${storeResult.cacheSize}`, testResults);

                // ãƒ†ã‚¹ãƒˆ2: ã‚­ãƒ£ãƒƒã‚·ãƒ¥å–å¾—ï¼ˆãƒ’ãƒƒãƒˆï¼‰
                const retrieveResult = bitCSP.cacheProbabilityResultsBit("test_key_1");

                log(`âœ… ã‚­ãƒ£ãƒƒã‚·ãƒ¥å–å¾—ãƒ†ã‚¹ãƒˆ: ${retrieveResult.success ? 'ãƒ’ãƒƒãƒˆ' : 'ãƒŸã‚¹'}`, testResults,
                    retrieveResult.success ? 'success' : 'error');
                if (retrieveResult.success) {
                    log(`   - ã‚¢ã‚¯ã‚»ã‚¹å›æ•°: ${retrieveResult.accessCount}`, testResults);
                    log(`   - ã‚­ãƒ£ãƒƒã‚·ãƒ¥å¹´é½¢: ${retrieveResult.age.toFixed(2)}ms`, testResults);
                    log(`   - ãƒ’ãƒƒãƒˆç‡: ${retrieveResult.cacheStats.hitRate}`, testResults);
                }

                // ãƒ†ã‚¹ãƒˆ3: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒŸã‚¹
                const missResult = bitCSP.cacheProbabilityResultsBit("nonexistent_key");
                log(`âœ… ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒŸã‚¹ãƒ†ã‚¹ãƒˆ: ${!missResult.success ? 'æ­£å¸¸ãƒŸã‚¹' : 'ã‚¨ãƒ©ãƒ¼'}`, testResults,
                    !missResult.success ? 'success' : 'error');

                // ãƒ†ã‚¹ãƒˆ4: è¤‡æ•°ã‚¨ãƒ³ãƒˆãƒªã§LRUãƒ†ã‚¹ãƒˆ
                for (let i = 0; i < 5; i++) {
                    bitCSP.cacheProbabilityResultsBit(`test_key_${i}`, { data: `test_data_${i}` });
                }

                const lruResult = bitCSP.cacheProbabilityResultsBit("test_key_0");
                log(`âœ… LRUè¤‡æ•°ã‚¨ãƒ³ãƒˆãƒªãƒ†ã‚¹ãƒˆ: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºç¢ºèª`, testResults, 'success');
                if (lruResult.success) {
                    log(`   - ç¾åœ¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚º: ${lruResult.cacheStats.cacheSize}/${lruResult.cacheStats.maxSize}`, testResults);
                    log(`   - ç¾åœ¨ãƒ’ãƒƒãƒˆç‡: ${lruResult.cacheStats.hitRate}`, testResults);
                }

                log("âœ… cacheProbabilityResultsBit() å…¨ãƒ†ã‚¹ãƒˆæˆåŠŸ", testResults, 'success');
                return true;

            } catch (error) {
                log(`âŒ cacheProbabilityResultsBit() ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, testResults, 'error');
                return false;
            }
        }

        // å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
        function runAllTests() {
            log("ğŸš€ Phase3-2 å…¨æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆé–‹å§‹", testResults, 'info');
            log("=" * 60, testResults);
            
            let allPassed = true;
            const tests = [
                { name: "calculateCellProbabilitiesBit()", func: testCalculateCellProbabilities },
                { name: "aggregateSolutionStatsBit()", func: testAggregateSolutionStats },
                { name: "optimizeProbabilityCalculationBit()", func: testOptimizeProbabilityCalculation },
                { name: "cacheProbabilityResultsBit()", func: testCacheProbabilityResults }
            ];

            for (const test of tests) {
                log(`\n--- ${test.name} ãƒ†ã‚¹ãƒˆ ---`, testResults, 'info');
                const passed = test.func();
                allPassed = allPassed && passed;
                log(`${test.name}: ${passed ? 'âœ… æˆåŠŸ' : 'âŒ å¤±æ•—'}`, testResults, passed ? 'success' : 'error');
            }

            log("\n" + "=" * 60, testResults);
            log(`ğŸ¯ Phase3-2 å…¨ãƒ†ã‚¹ãƒˆçµæœ: ${allPassed ? 'âœ… å…¨ã¦æˆåŠŸ' : 'âŒ ä¸€éƒ¨å¤±æ•—'}`, testResults, 
                allPassed ? 'success' : 'error');
        }

        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆé–¢æ•°ç¾¤ï¼ˆç°¡ç•¥ç‰ˆï¼‰
        function benchmarkProbabilityCalculation() {
            log("âš¡ ç¢ºç‡è¨ˆç®—æ€§èƒ½ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–‹å§‹", performanceResults, 'info');
            log("å®Ÿè£…äºˆå®š: å„ç¨®ã‚µã‚¤ã‚ºã§ã®ç¢ºç‡è¨ˆç®—æ€§èƒ½æ¸¬å®š", performanceResults, 'warning');
        }

        function benchmarkCachePerformance() {
            log("âš¡ ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ€§èƒ½ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–‹å§‹", performanceResults, 'info');
            log("å®Ÿè£…äºˆå®š: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆç‡ã¨LRUæ€§èƒ½æ¸¬å®š", performanceResults, 'warning');
        }

        function benchmarkLargeSetOptimization() {
            log("âš¡ å¤§è¦æ¨¡ã‚»ãƒƒãƒˆæœ€é©åŒ–ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–‹å§‹", performanceResults, 'info');
            log("å®Ÿè£…äºˆå®š: 20-29ã‚»ãƒ«ç¯„å›²ã§ã®ãƒãƒ£ãƒ³ã‚¯å‡¦ç†æ€§èƒ½æ¸¬å®š", performanceResults, 'warning');
        }

        function benchmarkPhase2Comparison() {
            log("ğŸ“Š Phase2æ¯”è¼ƒãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–‹å§‹", performanceResults, 'info');
            log("å®Ÿè£…äºˆå®š: Phase2ã®ç¢ºç‡è¨ˆç®—ã¨ã®æ€§èƒ½æ¯”è¼ƒ", performanceResults, 'warning');
        }

        // è©³ç´°ãƒ†ã‚¹ãƒˆé–¢æ•°ç¾¤ï¼ˆç°¡ç•¥ç‰ˆï¼‰
        function testComplexMultiGroup() {
            log("ğŸ” è¤‡æ•°ã‚°ãƒ«ãƒ¼ãƒ—çµ±åˆãƒ†ã‚¹ãƒˆé–‹å§‹", detailedResults, 'info');
            log("å®Ÿè£…äºˆå®š: 10ã‚°ãƒ«ãƒ¼ãƒ—ä»¥ä¸Šã®è¤‡é›‘ãªçµ±åˆå‡¦ç†ãƒ†ã‚¹ãƒˆ", detailedResults, 'warning');
        }

        function testCacheLRUBehavior() {
            log("ğŸ” ã‚­ãƒ£ãƒƒã‚·ãƒ¥LRUå‹•ä½œãƒ†ã‚¹ãƒˆé–‹å§‹", detailedResults, 'info');
            log("å®Ÿè£…äºˆå®š: LRUã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®è©³ç´°å‹•ä½œç¢ºèª", detailedResults, 'warning');
        }

        function testMemoryEfficiency() {
            log("ğŸ” ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ãƒ†ã‚¹ãƒˆé–‹å§‹", detailedResults, 'info');
            log("å®Ÿè£…äºˆå®š: ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®æ¸¬å®šã¨åˆ†æ", detailedResults, 'warning');
        }

        function testAccuracyComparison() {
            log("ğŸ” ç²¾åº¦æ¯”è¼ƒãƒ†ã‚¹ãƒˆé–‹å§‹", detailedResults, 'info');
            log("å®Ÿè£…äºˆå®š: å¾“æ¥ç‰ˆã¨ã®ç¢ºç‡è¨ˆç®—ç²¾åº¦æ¯”è¼ƒ", detailedResults, 'warning');
        }

        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¡¨ç¤º
        function updatePerformanceMetrics(metrics) {
            performanceMetrics.innerHTML = '';
            for (const [key, data] of Object.entries(metrics)) {
                const card = document.createElement('div');
                card.className = 'metric-card';
                card.innerHTML = `
                    <div class="metric-value">${data.value}</div>
                    <div class="metric-label">${data.label}</div>
                `;
                performanceMetrics.appendChild(card);
            }
        }

        // åˆæœŸåŒ–
        log("ğŸš€ Phase3-2ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†", testResults, 'success');
        log("ç¢ºç‡è¨ˆç®—ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ“ãƒƒãƒˆåŒ–ã¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥æœ€é©åŒ–ã‚’ãƒ†ã‚¹ãƒˆã—ã¾ã™", testResults, 'info');
    </script>
</body>
</html>