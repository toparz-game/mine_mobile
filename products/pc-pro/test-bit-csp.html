<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ“ãƒƒãƒˆCSPã‚½ãƒ«ãƒãƒ¼å‹•ä½œãƒ†ã‚¹ãƒˆ</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #f0f0f0; }
        .test-section { margin: 20px 0; padding: 15px; background: white; border-radius: 8px; }
        .test-title { font-weight: bold; color: #2196F3; margin-bottom: 10px; }
        .test-result { margin: 5px 0; }
        .success { color: #4CAF50; }
        .error { color: #F44336; }
        .info { color: #666; }
        .performance { background: #e3f2fd; padding: 10px; margin: 10px 0; border-radius: 4px; }
    </style>
</head>
<body>
    <h1>ğŸ¯ ãƒ“ãƒƒãƒˆCSPã‚½ãƒ«ãƒãƒ¼å‹•ä½œãƒ†ã‚¹ãƒˆ</h1>
    <div id="test-results"></div>

    <script src="../../core/minesweeper-core.js"></script>
    <script src="../pc/game.js"></script>
    <script src="modules/bit-minesweeper.js"></script>
    <script src="modules/bit-csp-solver.js"></script>
    <script src="modules/bit-csp-operations.js"></script>

    <script>
        class BitCSPTester {
            constructor() {
                this.results = [];
                this.testContainer = document.getElementById('test-results');
            }

            log(message, type = 'info') {
                this.results.push({ message, type });
                console.log(`[${type.toUpperCase()}] ${message}`);
            }

            addTestSection(title) {
                const section = document.createElement('div');
                section.className = 'test-section';
                section.innerHTML = `<div class="test-title">${title}</div>`;
                this.testContainer.appendChild(section);
                return section;
            }

            addResult(section, message, type = 'info') {
                const result = document.createElement('div');
                result.className = `test-result ${type}`;
                result.textContent = message;
                section.appendChild(result);
            }

            // ãƒ†ã‚¹ãƒˆ1: åŸºæœ¬çš„ãªãƒ“ãƒƒãƒˆæ¼”ç®—ã®ãƒ†ã‚¹ãƒˆ
            testBasicBitOperations() {
                const section = this.addTestSection('1. åŸºæœ¬ãƒ“ãƒƒãƒˆæ¼”ç®—ãƒ†ã‚¹ãƒˆ');
                
                try {
                    // ãƒ¢ãƒƒã‚¯ã®ã‚²ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
                    const mockGame = {
                        rows: 9, cols: 9, mineCount: 10,
                        revealed: Array(9).fill().map(() => Array(9).fill(false)),
                        flagged: Array(9).fill().map(() => Array(9).fill(false)),
                        board: Array(9).fill().map(() => Array(9).fill(0))
                    };
                    
                    const bitSystem = new BitMinesweeperSystem(9, 9);
                    const bitCSP = new BitCSPSolver(mockGame, bitSystem);
                    
                    // ãƒ“ãƒƒãƒˆè¨­å®šãƒ»å–å¾—ãƒ†ã‚¹ãƒˆ
                    bitCSP.setBit(bitCSP.candidateBits, 0, 0, true);
                    bitCSP.setBit(bitCSP.candidateBits, 4, 4, true);
                    bitCSP.setBit(bitCSP.candidateBits, 8, 8, true);
                    
                    const bit00 = bitCSP.getBit(bitCSP.candidateBits, 0, 0);
                    const bit44 = bitCSP.getBit(bitCSP.candidateBits, 4, 4);
                    const bit88 = bitCSP.getBit(bitCSP.candidateBits, 8, 8);
                    const bit11 = bitCSP.getBit(bitCSP.candidateBits, 1, 1);
                    
                    this.addResult(section, `ãƒ“ãƒƒãƒˆè¨­å®šãƒ†ã‚¹ãƒˆ: ${bit00 && bit44 && bit88 && !bit11 ? 'PASS' : 'FAIL'}`, 
                                 bit00 && bit44 && bit88 && !bit11 ? 'success' : 'error');
                    
                    // ãƒãƒ”ãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆãƒ†ã‚¹ãƒˆ
                    const popCount = bitCSP.popCountBits(bitCSP.candidateBits);
                    this.addResult(section, `ãƒãƒ”ãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚«ã‚¦ãƒ³ãƒˆ: ${popCount} (æœŸå¾…å€¤: 3) ${popCount === 3 ? 'PASS' : 'FAIL'}`, 
                                 popCount === 3 ? 'success' : 'error');
                    
                    // åº§æ¨™å¤‰æ›ãƒ†ã‚¹ãƒˆ
                    const coords = bitCSP.bitsToCoordList(bitCSP.candidateBits);
                    const expectedCoords = [{row: 0, col: 0}, {row: 4, col: 4}, {row: 8, col: 8}];
                    const coordsMatch = coords.length === 3 && 
                                      coords.every((c, i) => c.row === expectedCoords[i].row && c.col === expectedCoords[i].col);
                    
                    this.addResult(section, `åº§æ¨™å¤‰æ›ãƒ†ã‚¹ãƒˆ: ${coordsMatch ? 'PASS' : 'FAIL'}`, 
                                 coordsMatch ? 'success' : 'error');
                    
                    // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãƒ†ã‚¹ãƒˆ
                    const memUsage = bitCSP.getMemoryUsage();
                    this.addResult(section, `ãƒ¡ãƒ¢ãƒªå‰Šæ¸›ç‡: ${memUsage.reduction}%`, 'info');
                    
                } catch (error) {
                    this.addResult(section, `ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
            }

            // ãƒ†ã‚¹ãƒˆ2: ã‚»ãƒƒãƒˆæ¼”ç®—ã®ãƒ†ã‚¹ãƒˆ
            testSetOperations() {
                const section = this.addTestSection('2. ã‚»ãƒƒãƒˆæ¼”ç®—ãƒ†ã‚¹ãƒˆ');
                
                try {
                    const mockGame = {
                        rows: 5, cols: 5, mineCount: 5,
                        revealed: Array(5).fill().map(() => Array(5).fill(false)),
                        flagged: Array(5).fill().map(() => Array(5).fill(false)),
                        board: Array(5).fill().map(() => Array(5).fill(0))
                    };
                    
                    const bitSystem = new BitMinesweeperSystem(5, 5);
                    const bitCSP = new BitCSPOperations(mockGame, bitSystem);
                    
                    // ã‚»ãƒƒãƒˆ1: (0,0), (1,1), (2,2)
                    bitCSP.clearBits(bitCSP.tempBits1);
                    bitCSP.setBit(bitCSP.tempBits1, 0, 0, true);
                    bitCSP.setBit(bitCSP.tempBits1, 1, 1, true);
                    bitCSP.setBit(bitCSP.tempBits1, 2, 2, true);
                    
                    // ã‚»ãƒƒãƒˆ2: (1,1), (2,2), (3,3)
                    bitCSP.clearBits(bitCSP.tempBits2);
                    bitCSP.setBit(bitCSP.tempBits2, 1, 1, true);
                    bitCSP.setBit(bitCSP.tempBits2, 2, 2, true);
                    bitCSP.setBit(bitCSP.tempBits2, 3, 3, true);
                    
                    // ANDæ¼”ç®—ãƒ†ã‚¹ãƒˆï¼ˆç©é›†åˆï¼‰
                    bitCSP.andBits(bitCSP.tempBits1, bitCSP.tempBits2, bitCSP.tempBits3);
                    const andResult = bitCSP.popCountBits(bitCSP.tempBits3);
                    this.addResult(section, `ANDæ¼”ç®— (ç©é›†åˆ): ${andResult} ã‚»ãƒ« (æœŸå¾…å€¤: 2) ${andResult === 2 ? 'PASS' : 'FAIL'}`, 
                                 andResult === 2 ? 'success' : 'error');
                    
                    // ORæ¼”ç®—ãƒ†ã‚¹ãƒˆï¼ˆå’Œé›†åˆï¼‰
                    bitCSP.orBits(bitCSP.tempBits1, bitCSP.tempBits2, bitCSP.tempBits3);
                    const orResult = bitCSP.popCountBits(bitCSP.tempBits3);
                    this.addResult(section, `ORæ¼”ç®— (å’Œé›†åˆ): ${orResult} ã‚»ãƒ« (æœŸå¾…å€¤: 4) ${orResult === 4 ? 'PASS' : 'FAIL'}`, 
                                 orResult === 4 ? 'success' : 'error');
                    
                    // XORæ¼”ç®—ãƒ†ã‚¹ãƒˆï¼ˆå¯¾ç§°å·®é›†åˆï¼‰
                    bitCSP.xorBits(bitCSP.tempBits1, bitCSP.tempBits2, bitCSP.tempBits3);
                    const xorResult = bitCSP.popCountBits(bitCSP.tempBits3);
                    this.addResult(section, `XORæ¼”ç®— (å¯¾ç§°å·®): ${xorResult} ã‚»ãƒ« (æœŸå¾…å€¤: 2) ${xorResult === 2 ? 'PASS' : 'FAIL'}`, 
                                 xorResult === 2 ? 'success' : 'error');
                    
                } catch (error) {
                    this.addResult(section, `ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
            }

            // ãƒ†ã‚¹ãƒˆ3: åˆ¶ç´„ç”Ÿæˆã®ãƒ†ã‚¹ãƒˆ
            testConstraintGeneration() {
                const section = this.addTestSection('3. åˆ¶ç´„ç”Ÿæˆãƒ†ã‚¹ãƒˆ');
                
                try {
                    const mockGame = {
                        rows: 3, cols: 3, mineCount: 2,
                        revealed: [
                            [false, false, false],
                            [false, true,  false],
                            [false, false, false]
                        ],
                        flagged: Array(3).fill().map(() => Array(3).fill(false)),
                        board: [
                            [0, 0, 0],
                            [0, 2, 0],  // ä¸­å¤®ã‚»ãƒ«ã¯å‘¨å›²ã«åœ°é›·2å€‹
                            [0, 0, 0]
                        ]
                    };
                    
                    const bitSystem = new BitMinesweeperSystem(3, 3);
                    const bitCSP = new BitCSPOperations(mockGame, bitSystem);
                    
                    // æœªçŸ¥ã‚»ãƒ«ä¸€è¦§
                    const unknownCells = [];
                    for (let row = 0; row < 3; row++) {
                        for (let col = 0; col < 3; col++) {
                            if (!mockGame.revealed[row][col]) {
                                unknownCells.push({row, col});
                            }
                        }
                    }
                    
                    const constraints = bitCSP.generateConstraintsFromGroup(unknownCells);
                    
                    this.addResult(section, `ç”Ÿæˆã•ã‚ŒãŸåˆ¶ç´„æ•°: ${constraints.length}`, 'info');
                    
                    if (constraints.length > 0) {
                        const constraint = constraints[0];
                        this.addResult(section, `åˆ¶ç´„1 - ã‚»ãƒ«æ•°: ${constraint.cells.length}, æœŸå¾…åœ°é›·æ•°: ${constraint.expectedMines}`, 'info');
                        this.addResult(section, `åˆ¶ç´„ç”Ÿæˆãƒ†ã‚¹ãƒˆ: PASS`, 'success');
                    } else {
                        this.addResult(section, `åˆ¶ç´„ç”Ÿæˆãƒ†ã‚¹ãƒˆ: FAIL (åˆ¶ç´„ãŒç”Ÿæˆã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ)`, 'error');
                    }
                    
                } catch (error) {
                    this.addResult(section, `ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
            }

            // ãƒ†ã‚¹ãƒˆ4: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
            testPerformance() {
                const section = this.addTestSection('4. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ');
                
                try {
                    const sizes = [
                        {rows: 9, cols: 9, desc: 'åˆç´š (9Ã—9)'},
                        {rows: 16, cols: 16, desc: 'ä¸­ç´š (16Ã—16)'},
                        {rows: 16, cols: 30, desc: 'ä¸Šç´š (16Ã—30)'}
                    ];
                    
                    for (const size of sizes) {
                        const mockGame = {
                            rows: size.rows, cols: size.cols, mineCount: 40,
                            revealed: Array(size.rows).fill().map(() => Array(size.cols).fill(false)),
                            flagged: Array(size.rows).fill().map(() => Array(size.cols).fill(false)),
                            board: Array(size.rows).fill().map(() => Array(size.cols).fill(0))
                        };
                        
                        const bitSystem = new BitMinesweeperSystem(size.rows, size.cols);
                        const bitCSP = new BitCSPOperations(mockGame, bitSystem);
                        
                        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ: å¤§é‡ã®ãƒ“ãƒƒãƒˆæ¼”ç®—
                        const startTime = performance.now();
                        
                        for (let i = 0; i < 1000; i++) {
                            // ãƒ©ãƒ³ãƒ€ãƒ ãªã‚»ãƒ«ã«ãƒ“ãƒƒãƒˆã‚’è¨­å®š
                            const row = Math.floor(Math.random() * size.rows);
                            const col = Math.floor(Math.random() * size.cols);
                            bitCSP.setBit(bitCSP.candidateBits, row, col, true);
                        }
                        
                        // ã‚»ãƒƒãƒˆæ¼”ç®—ã‚’å®Ÿè¡Œ
                        for (let i = 0; i < 100; i++) {
                            bitCSP.andBits(bitCSP.candidateBits, bitCSP.tempBits1, bitCSP.tempBits2);
                            bitCSP.orBits(bitCSP.tempBits1, bitCSP.tempBits2, bitCSP.tempBits3);
                            bitCSP.popCountBits(bitCSP.tempBits3);
                        }
                        
                        const endTime = performance.now();
                        const duration = (endTime - startTime).toFixed(2);
                        
                        const memUsage = bitCSP.getMemoryUsage();
                        
                        this.addResult(section, `${size.desc}: ${duration}ms, ãƒ¡ãƒ¢ãƒªå‰Šæ¸›: ${memUsage.reduction}%`, 'info');
                    }
                    
                } catch (error) {
                    this.addResult(section, `ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
            }

            // å…¨ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ
            runAllTests() {
                this.log('ãƒ“ãƒƒãƒˆCSPã‚½ãƒ«ãƒãƒ¼ã®ãƒ†ã‚¹ãƒˆã‚’é–‹å§‹ã—ã¾ã™...', 'info');
                
                this.testBasicBitOperations();
                this.testSetOperations();
                this.testConstraintGeneration();
                this.testPerformance();
                
                this.log('å…¨ãƒ†ã‚¹ãƒˆãŒå®Œäº†ã—ã¾ã—ãŸ', 'info');
            }
        }

        // ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
        document.addEventListener('DOMContentLoaded', () => {
            const tester = new BitCSPTester();
            tester.runAllTests();
        });
    </script>
</body>
</html>