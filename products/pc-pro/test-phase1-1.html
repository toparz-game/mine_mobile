<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase1-1 Test</title>
</head>
<body>
    <h1>Phase1-1: 隣接セル取得のビット化メソッドテスト</h1>
    <div id="test-results"></div>
    <script src="../../core/minesweeper-core.js"></script>
    <script src="modules/bit-minesweeper.js"></script>
    <script src="modules/simple-bit-csp.js"></script>
    <script>
        function runPhase1_1Tests() {
            const results = [];
            
            try {
                // テスト用の小さなゲーム作成（10x10）
                const game = {
                    rows: 10,
                    cols: 10,
                    mineCount: 10,
                    board: Array(10).fill(null).map(() => Array(10).fill(0)),
                    revealed: Array(10).fill(null).map(() => Array(10).fill(false)),
                    flagged: Array(10).fill(null).map(() => Array(10).fill(false))
                };
                
                const bitSystem = new BitMinesweeperSystem(10, 10);
                const csp = new SimpleBitCSP(game, bitSystem);
                
                results.push("✅ SimpleBitCSP インスタンス作成成功");
                
                // Test 1: 基本的な隣接セル取得テスト
                const testBits = new Uint32Array(csp.intsNeeded);
                const resultBits = new Uint32Array(csp.intsNeeded);
                
                // 座標(5,5), (6,6), (4,4)にビット設定
                csp.setBit(testBits, 5, 5, true);
                csp.setBit(testBits, 6, 6, true);
                csp.setBit(testBits, 4, 4, true);
                
                // 座標(5,5)の隣接セル取得
                csp.getNeighborCellsBit(5, 5, testBits, resultBits);
                
                // 結果確認
                const bit_6_6 = csp.getBit(resultBits, 6, 6);
                const bit_4_4 = csp.getBit(resultBits, 4, 4);
                const bit_5_5 = csp.getBit(resultBits, 5, 5);
                
                if (bit_6_6 && bit_4_4 && !bit_5_5) {
                    results.push("✅ Test 1: getNeighborCellsBit() - 正常動作");
                } else {
                    results.push(`❌ Test 1: getNeighborCellsBit() - 異常 (6,6:${bit_6_6}, 4,4:${bit_4_4}, 5,5:${bit_5_5})`);
                }
                
                // Test 2: 隣接セル数カウントテスト
                const count = csp.countNeighborsBit(5, 5, testBits);
                if (count === 2) {
                    results.push("✅ Test 2: countNeighborsBit() - 正常動作 (count: 2)");
                } else {
                    results.push(`❌ Test 2: countNeighborsBit() - 異常 (count: ${count}, expected: 2)`);
                }
                
                // Test 3: 境界条件テスト（角のセル）
                csp.clearBits(testBits);
                csp.clearBits(resultBits);
                csp.setBit(testBits, 0, 1, true);
                csp.setBit(testBits, 1, 0, true);
                csp.setBit(testBits, 1, 1, true);
                
                csp.getNeighborCellsBit(0, 0, testBits, resultBits);
                const cornerCount = csp.countNeighborsBit(0, 0, testBits);
                
                if (cornerCount === 3) {
                    results.push("✅ Test 3: 境界条件テスト(角) - 正常動作 (count: 3)");
                } else {
                    results.push(`❌ Test 3: 境界条件テスト(角) - 異常 (count: ${cornerCount}, expected: 3)`);
                }
                
                // Test 4: 空の配列テスト
                csp.clearBits(testBits);
                const emptyCount = csp.countNeighborsBit(5, 5, testBits);
                
                if (emptyCount === 0) {
                    results.push("✅ Test 4: 空配列テスト - 正常動作 (count: 0)");
                } else {
                    results.push(`❌ Test 4: 空配列テスト - 異常 (count: ${emptyCount}, expected: 0)`);
                }
                
                // Test 5: ビット演算テスト
                const bits1 = new Uint32Array(csp.intsNeeded);
                const bits2 = new Uint32Array(csp.intsNeeded);
                const resultBitsOp = new Uint32Array(csp.intsNeeded);
                
                csp.setBit(bits1, 3, 3, true);
                csp.setBit(bits1, 4, 4, true);
                csp.setBit(bits2, 4, 4, true);
                csp.setBit(bits2, 5, 5, true);
                
                // AND演算テスト
                csp.andBits(bits1, bits2, resultBitsOp);
                const andResult = csp.getBit(resultBitsOp, 4, 4) && 
                                !csp.getBit(resultBitsOp, 3, 3) && 
                                !csp.getBit(resultBitsOp, 5, 5);
                
                if (andResult) {
                    results.push("✅ Test 5a: AND演算 - 正常動作");
                } else {
                    results.push("❌ Test 5a: AND演算 - 異常");
                }
                
                // OR演算テスト
                csp.orBits(bits1, bits2, resultBitsOp);
                const orResult = csp.getBit(resultBitsOp, 3, 3) && 
                               csp.getBit(resultBitsOp, 4, 4) && 
                               csp.getBit(resultBitsOp, 5, 5);
                
                if (orResult) {
                    results.push("✅ Test 5b: OR演算 - 正常動作");
                } else {
                    results.push("❌ Test 5b: OR演算 - 異常");
                }
                
                // コピーテスト
                csp.copyBits(bits1, resultBitsOp);
                const copyResult = csp.equalsBits(bits1, resultBitsOp);
                
                if (copyResult) {
                    results.push("✅ Test 5c: ビット配列コピー - 正常動作");
                } else {
                    results.push("❌ Test 5c: ビット配列コピー - 異常");
                }
                
                // 空チェックテスト
                csp.clearBits(resultBitsOp);
                const emptyResult = csp.isEmptyBits(resultBitsOp);
                const notEmptyResult = !csp.isEmptyBits(bits1);
                
                if (emptyResult && notEmptyResult) {
                    results.push("✅ Test 5d: 空配列チェック - 正常動作");
                } else {
                    results.push("❌ Test 5d: 空配列チェック - 異常");
                }
                
                // Test 6: デバッグ機能テスト
                try {
                    // ビット表示テスト（エラーなく実行できるか）
                    csp.debugPrintBits(bits1, "テスト用ビット配列");
                    csp.debugBitStats(bits1, "テスト統計");
                    
                    // 座標変換テスト
                    const testCoords = [{row: 2, col: 2}, {row: 3, col: 3}];
                    const coordBits = new Uint32Array(csp.intsNeeded);
                    csp.coordsToBits(testCoords, coordBits);
                    const convertedCoords = csp.bitsToCoords(coordBits);
                    
                    const coordsMatch = testCoords.length === convertedCoords.length &&
                        testCoords.every(coord => 
                            convertedCoords.some(c => c.row === coord.row && c.col === coord.col)
                        );
                    
                    if (coordsMatch) {
                        results.push("✅ Test 6: デバッグ機能・座標変換 - 正常動作");
                    } else {
                        results.push("❌ Test 6: デバッグ機能・座標変換 - 異常");
                    }
                } catch (debugError) {
                    results.push(`❌ Test 6: デバッグ機能でエラー - ${debugError.message}`);
                }
                
            } catch (error) {
                results.push(`❌ エラー発生: ${error.message}`);
                console.error(error);
            }
            
            // 結果表示
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = '<h2>テスト結果</h2>' + 
                results.map(result => `<p>${result}</p>`).join('');
            
            console.log('Phase1-1 テスト結果:', results);
            
            return results.every(r => r.startsWith('✅'));
        }
        
        // ページ読み込み完了後にテスト実行
        window.addEventListener('load', () => {
            setTimeout(runPhase1_1Tests, 100);
        });
    </script>
</body>
</html>