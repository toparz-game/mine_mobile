<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phase3-1: å°è¦æ¨¡å®Œå…¨æ¢ç´¢ã®ãƒ“ãƒƒãƒˆåŒ–åŸºç›¤ãƒ†ã‚¹ãƒˆ</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }
        .test-section {
            background-color: #2d2d2d;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .success { color: #4CAF50; }
        .error { color: #f44336; }
        .warning { color: #ff9800; }
        .info { color: #2196F3; }
        .test-button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: all 0.3s;
        }
        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }
        .test-results {
            background-color: #1e1e1e;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            max-height: 400px;
            overflow-y: auto;
        }
        .performance-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .metric-card {
            background-color: #333;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }
        .metric-label {
            font-size: 14px;
            color: #bbb;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ Phase3-1: å°è¦æ¨¡å®Œå…¨æ¢ç´¢ã®ãƒ“ãƒƒãƒˆåŒ–åŸºç›¤</h1>
            <p>ç›®æ¨™: â‰¤29ã‚»ãƒ«ã®åˆ¶ç´„ã‚»ãƒƒãƒˆã«å¯¾ã™ã‚‹è¶…é«˜é€Ÿå®Œå…¨æ¢ç´¢ã‚·ã‚¹ãƒ†ãƒ  (64x64ç›¤é¢å¯¾å¿œ)</p>
            <p>ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›®æ¨™: &lt;1ms/ã‚»ãƒƒãƒˆ</p>
        </div>

        <div class="test-section">
            <h2>ğŸ“‹ Phase3-1 æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</h2>
            <button class="test-button" onclick="testGenerateConfigurations()">1. generateConfigurationsBit() ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testValidateConfiguration()">2. validateConfigurationBit() ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testEnumerateValidConfigs()">3. enumerateValidConfigsBit() ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testOptimizeSmallSetSolving()">4. optimizeSmallSetSolvingBit() ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="runAllTests()">ğŸ¯ å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
            <button class="test-button" onclick="clearResults()" style="background: linear-gradient(45deg, #f44336, #d32f2f);">ğŸ§¹ çµæœã‚¯ãƒªã‚¢</button>
            <div id="testResults" class="test-results"></div>
        </div>

        <div class="test-section">
            <h2>âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š</h2>
            <button class="test-button" onclick="benchmarkSmallSets()">å°è¦æ¨¡ã‚»ãƒƒãƒˆãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ (2-18ã‚»ãƒ«)</button>
            <button class="test-button" onclick="benchmarkMediumSets()">ä¸­è¦æ¨¡ã‚»ãƒƒãƒˆãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ (20-25ã‚»ãƒ«)</button>
            <button class="test-button" onclick="benchmarkLargeSets()">å¤§è¦æ¨¡ã‚»ãƒƒãƒˆãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ (26-29ã‚»ãƒ«)</button>
            <button class="test-button" onclick="benchmarkExtremeTest()">âœ¨ æ¥µé™ãƒ†ã‚¹ãƒˆ (29ã‚»ãƒ«5å„„ãƒ‘ã‚¿ãƒ¼ãƒ³)</button>
            <button class="test-button" onclick="benchmarkComparisonTest()">Phase2æ¯”è¼ƒãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯</button>
            <div id="performanceResults" class="test-results"></div>
            <div id="performanceMetrics" class="performance-metrics"></div>
        </div>

        <div class="test-section">
            <h2>ğŸ” è©³ç´°å‹•ä½œãƒ†ã‚¹ãƒˆ</h2>
            <button class="test-button" onclick="testComplexConstraints()">è¤‡é›‘åˆ¶ç´„ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testEdgeCases()">ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ</button>
            <button class="test-button" onclick="testMemoryEfficiency()">ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ãƒ†ã‚¹ãƒˆ</button>
            <div id="detailedResults" class="test-results"></div>
        </div>
    </div>

    <script src="modules/bit-minesweeper.js"></script>
    <script src="modules/simple-bit-csp.js"></script>
    <script>
        let testResults = document.getElementById('testResults');
        let performanceResults = document.getElementById('performanceResults');
        let detailedResults = document.getElementById('detailedResults');
        let performanceMetrics = document.getElementById('performanceMetrics');

        // ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ¢ãƒƒã‚¯ã‚²ãƒ¼ãƒ ç’°å¢ƒ
        const mockGame = {
            rows: 16,
            cols: 16,
            mines: 40,
            board: Array(16).fill().map(() => Array(16).fill(0)),
            isValidCoord: (row, col) => row >= 0 && row < 16 && col >= 0 && col < 16
        };

        // BitMinesweeperSystemã¨SimpleBitCSPã‚’åˆæœŸåŒ–
        const bitSystem = new BitMinesweeperSystem(mockGame);
        const bitCSP = new SimpleBitCSP(mockGame, bitSystem);

        function log(message, element = testResults, className = '') {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}\n`;
            element.textContent += logMessage;
            if (className) {
                element.className += ` ${className}`;
            }
            element.scrollTop = element.scrollHeight;
        }

        function clearResults() {
            testResults.textContent = '';
            performanceResults.textContent = '';
            detailedResults.textContent = '';
            performanceMetrics.innerHTML = '';
        }

        // 1. generateConfigurationsBit() ãƒ†ã‚¹ãƒˆ
        function testGenerateConfigurations() {
            log("=== generateConfigurationsBit() ãƒ†ã‚¹ãƒˆé–‹å§‹ ===", testResults, 'info');
            
            try {
                // ãƒ†ã‚¹ãƒˆ1: 3ã‚»ãƒ«ã®åˆ¶ç´„ã‚°ãƒ«ãƒ¼ãƒ—
                const testGroup1 = {
                    cells: [
                        {row: 1, col: 1},
                        {row: 1, col: 2},
                        {row: 2, col: 1}
                    ]
                };

                const configs1 = bitCSP.generateConfigurationsBit(testGroup1);
                log(`âœ… 3ã‚»ãƒ«åˆ¶ç´„ã‚°ãƒ«ãƒ¼ãƒ—: ${configs1.length}è¨­å®šãƒ‘ã‚¿ãƒ¼ãƒ³ç”Ÿæˆï¼ˆæœŸå¾…å€¤: 8ï¼‰`, testResults, 'success');
                
                if (configs1.length !== 8) {
                    log(`âŒ ã‚¨ãƒ©ãƒ¼: æœŸå¾…å€¤8ã«å¯¾ã—ã¦${configs1.length}`, testResults, 'error');
                    return false;
                }

                // ãƒ†ã‚¹ãƒˆ2: 5ã‚»ãƒ«ã®åˆ¶ç´„ã‚°ãƒ«ãƒ¼ãƒ—
                const testGroup2 = {
                    cells: [
                        {row: 0, col: 0}, {row: 0, col: 1},
                        {row: 1, col: 0}, {row: 1, col: 1}, {row: 1, col: 2}
                    ]
                };

                const configs2 = bitCSP.generateConfigurationsBit(testGroup2);
                log(`âœ… 5ã‚»ãƒ«åˆ¶ç´„ã‚°ãƒ«ãƒ¼ãƒ—: ${configs2.length}è¨­å®šãƒ‘ã‚¿ãƒ¼ãƒ³ç”Ÿæˆï¼ˆæœŸå¾…å€¤: 32ï¼‰`, testResults, 'success');
                
                if (configs2.length !== 32) {
                    log(`âŒ ã‚¨ãƒ©ãƒ¼: æœŸå¾…å€¤32ã«å¯¾ã—ã¦${configs2.length}`, testResults, 'error');
                    return false;
                }

                // ãƒ†ã‚¹ãƒˆ3: 16ã‚»ãƒ«ãƒ†ã‚¹ãƒˆ (æ–°åˆ¶é™å†…)
                const testGroup3 = {
                    cells: Array(16).fill().map((_, i) => ({row: 0, col: i}))
                };

                const configs3 = bitCSP.generateConfigurationsBit(testGroup3);
                log(`âœ… 16ã‚»ãƒ«ãƒ†ã‚¹ãƒˆ: ${configs3.length}è¨­å®šãƒ‘ã‚¿ãƒ¼ãƒ³ç”Ÿæˆï¼ˆæœŸå¾…å€¤: 65536ï¼‰`, testResults, 'success');
                
                if (configs3.length !== 65536) {
                    log(`âŒ ã‚¨ãƒ©ãƒ¼: æœŸå¾…å€¤ 65536 ã«å¯¾ã—ã¦${configs3.length}`, testResults, 'error');
                    return false;
                }

                // ãƒ†ã‚¹ãƒˆ4: 17ã‚»ãƒ«ãƒ†ã‚¹ãƒˆ (æ–°åˆ¶é™å†…)
                const testGroup4 = {
                    cells: Array(17).fill().map((_, i) => ({row: i < 16 ? 0 : 1, col: i % 16}))
                };

                const configs4 = bitCSP.generateConfigurationsBit(testGroup4);
                log(`âœ… 17ã‚»ãƒ«ãƒ†ã‚¹ãƒˆ: ${configs4.length}è¨­å®šãƒ‘ã‚¿ãƒ¼ãƒ³ç”Ÿæˆï¼ˆæœŸå¾…å€¤: 131072ï¼‰`, testResults, 'success');
                
                if (configs4.length !== 131072) {
                    log(`âŒ ã‚¨ãƒ©ãƒ¼: æœŸå¾…å€¤ 131072 ã«å¯¾ã—ã¦${configs4.length}`, testResults, 'error');
                    return false;
                }

                // ãƒ†ã‚¹ãƒˆ5: 20ã‚»ãƒ«ãƒ†ã‚¹ãƒˆ (æ–°ä¸Šé™)
                const testGroup5 = {
                    cells: Array(20).fill().map((_, i) => ({row: Math.floor(i / 4), col: i % 4}))
                };

                const configs5 = bitCSP.generateConfigurationsBit(testGroup5);
                log(`âœ… 20ã‚»ãƒ«ä¸Šé™ãƒ†ã‚¹ãƒˆ: ${configs5.length}è¨­å®šãƒ‘ã‚¿ãƒ¼ãƒ³ç”Ÿæˆï¼ˆæœŸå¾…å€¤: 1048576ï¼‰`, testResults, 'success');
                
                if (configs5.length !== 1048576) {
                    log(`âŒ ã‚¨ãƒ©ãƒ¼: æœŸå¾…å€¤ 1048576 ã«å¯¾ã—ã¦${configs5.length}`, testResults, 'error');
                    return false;
                }

                // ãƒ†ã‚¹ãƒˆ6: 25ã‚»ãƒ«å¤§è¦æ¨¡ãƒ†ã‚¹ãƒˆ (64x64å¯¾å¿œ)
                const testGroup6 = {
                    cells: Array(25).fill().map((_, i) => ({row: Math.floor(i / 5), col: i % 5}))
                };

                const configs6 = bitCSP.generateConfigurationsBit(testGroup6);
                log(`âœ… 25ã‚»ãƒ«å¤§è¦æ¨¡ãƒ†ã‚¹ãƒˆ: ${configs6.length}è¨­å®šãƒ‘ã‚¿ãƒ¼ãƒ³ç”Ÿæˆï¼ˆæœŸå¾…å€¤: 33554432ï¼‰`, testResults, 'info');
                
                if (configs6.length !== 33554432) {
                    log(`âŒ ã‚¨ãƒ©ãƒ¼: æœŸå¾…å€¤ 33554432 ã«å¯¾ã—ã¦${configs6.length}`, testResults, 'error');
                    return false;
                }

                // ãƒ†ã‚¹ãƒˆ7: 29ã‚»ãƒ«æœ€å¤§ãƒ†ã‚¹ãƒˆ (æœ€é«˜ä¸Šé™)
                const testGroup7 = {
                    cells: Array(29).fill().map((_, i) => ({row: Math.floor(i / 6), col: i % 6}))
                };

                const configs7 = bitCSP.generateConfigurationsBit(testGroup7);
                log(`âœ… 29ã‚»ãƒ«æœ€å¤§ãƒ†ã‚¹ãƒˆ: ${configs7.length}è¨­å®šãƒ‘ã‚¿ãƒ¼ãƒ³ç”Ÿæˆï¼ˆæœŸå¾…å€¤: 536870912ï¼‰`, testResults, 'info');
                
                if (configs7.length !== 536870912) {
                    log(`âŒ ã‚¨ãƒ©ãƒ¼: æœŸå¾…å€¤ 536870912 ã«å¯¾ã—ã¦${configs7.length}`, testResults, 'error');
                    return false;
                }

                // ãƒ†ã‚¹ãƒˆ8: åˆ¶é™è¶…éãƒ†ã‚¹ãƒˆ (30ã‚»ãƒ«)
                const testGroup8 = {
                    cells: Array(30).fill().map((_, i) => ({row: Math.floor(i / 6), col: i % 6}))
                };

                const configs8 = bitCSP.generateConfigurationsBit(testGroup8);
                log(`âœ… 30ã‚»ãƒ«åˆ¶é™è¶…éãƒ†ã‚¹ãƒˆ: ${configs8.length}è¨­å®šãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆæœŸå¾…å€¤: 0ï¼‰`, testResults, 'warning');
                
                if (configs8.length !== 0) {
                    log(`âŒ ã‚¨ãƒ©ãƒ¼: åˆ¶é™è¶…éæ™‚ã¯0ã‚’è¿”ã™ã¹ã`, testResults, 'error');
                    return false;
                }

                log("âœ… generateConfigurationsBit() å…¨ãƒ†ã‚¹ãƒˆæˆåŠŸ", testResults, 'success');
                return true;

            } catch (error) {
                log(`âŒ generateConfigurationsBit() ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, testResults, 'error');
                return false;
            }
        }

        // 2. validateConfigurationBit() ãƒ†ã‚¹ãƒˆ
        function testValidateConfiguration() {
            log("=== validateConfigurationBit() ãƒ†ã‚¹ãƒˆé–‹å§‹ ===", testResults, 'info');
            
            try {
                // ãƒ†ã‚¹ãƒˆåˆ¶ç´„: 3ã‚»ãƒ«ã§åœ°é›·æ•°2å€‹
                const constraint = {
                    cells: [{row: 0, col: 0}, {row: 0, col: 1}, {row: 1, col: 0}],
                    count: 2
                };

                // åˆ¶ç´„ã®ãƒ“ãƒƒãƒˆãƒãƒƒãƒ—ã‚’ç”Ÿæˆ
                const constraintCellsBits = new Uint32Array(bitCSP.intsNeeded);
                bitCSP.bitSystem.coordsToBits(constraint.cells, constraintCellsBits);
                constraint.cellsBits = constraintCellsBits;

                // ãƒ†ã‚¹ãƒˆè¨­å®š1: åœ°é›·2å€‹ï¼ˆå¦¥å½“ï¼‰
                const validConfig = {
                    cellsBits: new Uint32Array(bitCSP.intsNeeded),
                    cells: constraint.cells,
                    mineCount: 2
                };
                
                // (0,0)ã¨(0,1)ã«åœ°é›·ã‚’é…ç½®
                const bit1 = bitCSP.bitSystem.coordToBit(0, 0);
                const bit2 = bitCSP.bitSystem.coordToBit(0, 1);
                validConfig.cellsBits[Math.floor(bit1/32)] |= (1 << (bit1%32));
                validConfig.cellsBits[Math.floor(bit2/32)] |= (1 << (bit2%32));

                const isValid1 = bitCSP.validateConfigurationBit(validConfig, [constraint]);
                log(`âœ… å¦¥å½“ãªè¨­å®šãƒ†ã‚¹ãƒˆ: ${isValid1 ? 'å¦¥å½“' : 'ç„¡åŠ¹'}ï¼ˆæœŸå¾…å€¤: å¦¥å½“ï¼‰`, testResults, 'success');

                // ãƒ†ã‚¹ãƒˆè¨­å®š2: åœ°é›·3å€‹ï¼ˆç„¡åŠ¹ï¼‰
                const invalidConfig = {
                    cellsBits: new Uint32Array(bitCSP.intsNeeded),
                    cells: constraint.cells,
                    mineCount: 3
                };
                
                // å…¨ã‚»ãƒ«ã«åœ°é›·ã‚’é…ç½®
                for (const cell of constraint.cells) {
                    const bit = bitCSP.bitSystem.coordToBit(cell.row, cell.col);
                    invalidConfig.cellsBits[Math.floor(bit/32)] |= (1 << (bit%32));
                }

                const isValid2 = bitCSP.validateConfigurationBit(invalidConfig, [constraint]);
                log(`âœ… ç„¡åŠ¹ãªè¨­å®šãƒ†ã‚¹ãƒˆ: ${isValid2 ? 'å¦¥å½“' : 'ç„¡åŠ¹'}ï¼ˆæœŸå¾…å€¤: ç„¡åŠ¹ï¼‰`, testResults, 'success');

                if (isValid1 && !isValid2) {
                    log("âœ… validateConfigurationBit() å…¨ãƒ†ã‚¹ãƒˆæˆåŠŸ", testResults, 'success');
                    return true;
                } else {
                    log("âŒ validateConfigurationBit() ãƒ†ã‚¹ãƒˆå¤±æ•—", testResults, 'error');
                    return false;
                }

            } catch (error) {
                log(`âŒ validateConfigurationBit() ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, testResults, 'error');
                return false;
            }
        }

        // 3. enumerateValidConfigsBit() ãƒ†ã‚¹ãƒˆ
        function testEnumerateValidConfigs() {
            log("=== enumerateValidConfigsBit() ãƒ†ã‚¹ãƒˆé–‹å§‹ ===", testResults, 'info');
            
            try {
                // 2ã‚»ãƒ«ã€åœ°é›·1å€‹ã®åˆ¶ç´„ã‚°ãƒ«ãƒ¼ãƒ—
                const constraintGroup = {
                    cells: [{row: 0, col: 0}, {row: 0, col: 1}],
                    constraints: [
                        {
                            cells: [{row: 0, col: 0}, {row: 0, col: 1}],
                            count: 1
                        }
                    ]
                };

                // åˆ¶ç´„ã®ãƒ“ãƒƒãƒˆãƒãƒƒãƒ—ã‚’ç”Ÿæˆ
                const constraintCellsBits = new Uint32Array(bitCSP.intsNeeded);
                bitCSP.bitSystem.coordsToBits(constraintGroup.constraints[0].cells, constraintCellsBits);
                constraintGroup.constraints[0].cellsBits = constraintCellsBits;

                const validConfigs = bitCSP.enumerateValidConfigsBit(constraintGroup);
                log(`âœ… 2ã‚»ãƒ«1åœ°é›·åˆ¶ç´„: ${validConfigs.length}å€‹ã®æœ‰åŠ¹è¨­å®šï¼ˆæœŸå¾…å€¤: 2ï¼‰`, testResults, 'success');
                
                if (validConfigs.length !== 2) {
                    log(`âŒ ã‚¨ãƒ©ãƒ¼: æœŸå¾…å€¤2ã«å¯¾ã—ã¦${validConfigs.length}`, testResults, 'error');
                    return false;
                }

                // ã‚ˆã‚Šè¤‡é›‘ãªã‚±ãƒ¼ã‚¹: 3ã‚»ãƒ«2åœ°é›·åˆ¶ç´„
                const complexGroup = {
                    cells: [{row: 1, col: 1}, {row: 1, col: 2}, {row: 2, col: 1}],
                    constraints: [
                        {
                            cells: [{row: 1, col: 1}, {row: 1, col: 2}, {row: 2, col: 1}],
                            count: 2
                        }
                    ]
                };

                // åˆ¶ç´„ã®ãƒ“ãƒƒãƒˆãƒãƒƒãƒ—ã‚’ç”Ÿæˆ
                const complexConstraintCellsBits = new Uint32Array(bitCSP.intsNeeded);
                bitCSP.bitSystem.coordsToBits(complexGroup.constraints[0].cells, complexConstraintCellsBits);
                complexGroup.constraints[0].cellsBits = complexConstraintCellsBits;

                const complexValidConfigs = bitCSP.enumerateValidConfigsBit(complexGroup);
                log(`âœ… 3ã‚»ãƒ«2åœ°é›·åˆ¶ç´„: ${complexValidConfigs.length}å€‹ã®æœ‰åŠ¹è¨­å®šï¼ˆæœŸå¾…å€¤: 3ï¼‰`, testResults, 'success');

                if (complexValidConfigs.length !== 3) {
                    log(`âŒ ã‚¨ãƒ©ãƒ¼: æœŸå¾…å€¤3ã«å¯¾ã—ã¦${complexValidConfigs.length}`, testResults, 'error');
                    return false;
                }

                log("âœ… enumerateValidConfigsBit() å…¨ãƒ†ã‚¹ãƒˆæˆåŠŸ", testResults, 'success');
                return true;

            } catch (error) {
                log(`âŒ enumerateValidConfigsBit() ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, testResults, 'error');
                return false;
            }
        }

        // 4. optimizeSmallSetSolvingBit() ãƒ†ã‚¹ãƒˆ
        function testOptimizeSmallSetSolving() {
            log("=== optimizeSmallSetSolvingBit() ãƒ†ã‚¹ãƒˆé–‹å§‹ ===", testResults, 'info');
            
            try {
                // å°è¦æ¨¡åˆ¶ç´„ã‚°ãƒ«ãƒ¼ãƒ—ï¼ˆ5ã‚»ãƒ«ã€2åœ°é›·ï¼‰
                const constraintGroup = {
                    cells: [
                        {row: 2, col: 2}, {row: 2, col: 3},
                        {row: 3, col: 2}, {row: 3, col: 3}, {row: 3, col: 4}
                    ],
                    constraints: [
                        {
                            cells: [{row: 2, col: 2}, {row: 2, col: 3}, {row: 3, col: 2}],
                            count: 1
                        },
                        {
                            cells: [{row: 3, col: 2}, {row: 3, col: 3}, {row: 3, col: 4}],
                            count: 1
                        }
                    ]
                };

                // åˆ¶ç´„ã®ãƒ“ãƒƒãƒˆãƒãƒƒãƒ—ã‚’ç”Ÿæˆ
                for (const constraint of constraintGroup.constraints) {
                    const constraintCellsBits = new Uint32Array(bitCSP.intsNeeded);
                    bitCSP.bitSystem.coordsToBits(constraint.cells, constraintCellsBits);
                    constraint.cellsBits = constraintCellsBits;
                }

                const startTime = performance.now();
                const result = bitCSP.optimizeSmallSetSolvingBit(constraintGroup);
                const endTime = performance.now();

                log(`âœ… è§£æ±ºçµæœ: ${result.success ? 'æˆåŠŸ' : 'å¤±æ•—'}`, testResults, result.success ? 'success' : 'error');
                if (result.success) {
                    log(`   - è§£æ±ºãƒ‘ã‚¿ãƒ¼ãƒ³æ•°: ${result.solutionCount}`, testResults);
                    log(`   - ã‚»ãƒ«æ•°: ${result.cellCount}`, testResults);
                    log(`   - å®Ÿè¡Œæ™‚é–“: ${result.executionTime.toFixed(4)}ms`, testResults);
                    log(`   - å¹³å‡æ™‚é–“/è§£: ${result.averageTimePerSolution.toFixed(4)}ms`, testResults);
                    
                    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›®æ¨™ãƒã‚§ãƒƒã‚¯
                    if (result.executionTime < 1.0) {
                        log(`ğŸ¯ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›®æ¨™é”æˆï¼ (${result.executionTime.toFixed(4)}ms < 1ms)`, testResults, 'success');
                    } else {
                        log(`âš ï¸ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›®æ¨™æœªé”æˆ (${result.executionTime.toFixed(4)}ms â‰¥ 1ms)`, testResults, 'warning');
                    }

                    // ã‚»ãƒ«ç¢ºç‡ã®ç¢ºèª
                    log(`   - ã‚»ãƒ«ç¢ºç‡:`, testResults);
                    for (const [cellKey, probability] of Object.entries(result.cellProbabilities)) {
                        log(`     ${cellKey}: ${(probability * 100).toFixed(1)}%`, testResults);
                    }
                } else {
                    log(`   - å¤±æ•—ç†ç”±: ${result.reason}`, testResults, 'error');
                }

                // åˆ¶é™è¶…éãƒ†ã‚¹ãƒˆ (30ã‚»ãƒ«ã§29ã‚»ãƒ«åˆ¶é™ã‚’è¶…é)
                const largeGroup = {
                    cells: Array(30).fill().map((_, i) => ({row: Math.floor(i / 6), col: i % 6})),
                    constraints: []
                };

                const largeResult = bitCSP.optimizeSmallSetSolvingBit(largeGroup);
                log(`âœ… åˆ¶é™è¶…éãƒ†ã‚¹ãƒˆ: ${largeResult.success ? 'æˆåŠŸï¼ˆã‚¨ãƒ©ãƒ¼ï¼‰' : 'æ­£å¸¸æ‹’å¦'}`, testResults, 
                    largeResult.success ? 'error' : 'success');

                if (!largeResult.success && largeResult.reason === 'set_too_large') {
                    log("âœ… optimizeSmallSetSolvingBit() å…¨ãƒ†ã‚¹ãƒˆæˆåŠŸ", testResults, 'success');
                    return true;
                } else {
                    log("âŒ optimizeSmallSetSolvingBit() ãƒ†ã‚¹ãƒˆå¤±æ•—", testResults, 'error');
                    return false;
                }

            } catch (error) {
                log(`âŒ optimizeSmallSetSolvingBit() ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, testResults, 'error');
                return false;
            }
        }

        // å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
        function runAllTests() {
            log("ğŸš€ Phase3-1 å…¨æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆé–‹å§‹", testResults, 'info');
            log("=" * 60, testResults);
            
            let allPassed = true;
            const tests = [
                { name: "generateConfigurationsBit()", func: testGenerateConfigurations },
                { name: "validateConfigurationBit()", func: testValidateConfiguration },
                { name: "enumerateValidConfigsBit()", func: testEnumerateValidConfigs },
                { name: "optimizeSmallSetSolvingBit()", func: testOptimizeSmallSetSolving }
            ];

            for (const test of tests) {
                log(`\n--- ${test.name} ãƒ†ã‚¹ãƒˆ ---`, testResults, 'info');
                const passed = test.func();
                allPassed = allPassed && passed;
                log(`${test.name}: ${passed ? 'âœ… æˆåŠŸ' : 'âŒ å¤±æ•—'}`, testResults, passed ? 'success' : 'error');
            }

            log("\n" + "=" * 60, testResults);
            log(`ğŸ¯ Phase3-1 å…¨ãƒ†ã‚¹ãƒˆçµæœ: ${allPassed ? 'âœ… å…¨ã¦æˆåŠŸ' : 'âŒ ä¸€éƒ¨å¤±æ•—'}`, testResults, 
                allPassed ? 'success' : 'error');
        }

        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ: å°è¦æ¨¡ã‚»ãƒƒãƒˆ
        function benchmarkSmallSets() {
            log("âš¡ å°è¦æ¨¡ã‚»ãƒƒãƒˆï¼ˆ2-18ã‚»ãƒ«ï¼‰ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–‹å§‹", performanceResults, 'info');
            
            const results = [];
            for (let cellCount = 2; cellCount <= 18; cellCount++) {
                const cells = Array(cellCount).fill().map((_, i) => ({
                    row: Math.floor(i / 4),
                    col: i % 4
                }));

                const constraintGroup = {
                    cells: cells,
                    constraints: [
                        {
                            cells: cells.slice(0, Math.min(3, cellCount)),
                            count: 1
                        }
                    ]
                };

                // åˆ¶ç´„ã®ãƒ“ãƒƒãƒˆãƒãƒƒãƒ—ã‚’ç”Ÿæˆ
                const constraintCellsBits = new Uint32Array(bitCSP.intsNeeded);
                bitCSP.bitSystem.coordsToBits(constraintGroup.constraints[0].cells, constraintCellsBits);
                constraintGroup.constraints[0].cellsBits = constraintCellsBits;

                const startTime = performance.now();
                const result = bitCSP.optimizeSmallSetSolvingBit(constraintGroup);
                const endTime = performance.now();

                results.push({
                    cellCount: cellCount,
                    executionTime: result.executionTime,
                    solutionCount: result.success ? result.solutionCount : 0,
                    success: result.success
                });

                log(`${cellCount}ã‚»ãƒ«: ${result.executionTime.toFixed(4)}ms (${result.success ? result.solutionCount + 'è§£' : 'å¤±æ•—'})`, 
                    performanceResults, result.success ? 'success' : 'error');
            }

            // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¡¨ç¤º
            const avgTime = results.filter(r => r.success).reduce((sum, r) => sum + r.executionTime, 0) / 
                           results.filter(r => r.success).length;
            const maxTime = Math.max(...results.filter(r => r.success).map(r => r.executionTime));
            const targetAchieved = results.filter(r => r.success && r.executionTime < 1.0).length;

            updatePerformanceMetrics({
                'avg_time': { value: avgTime.toFixed(4) + 'ms', label: 'å¹³å‡å®Ÿè¡Œæ™‚é–“' },
                'max_time': { value: maxTime.toFixed(4) + 'ms', label: 'æœ€å¤§å®Ÿè¡Œæ™‚é–“' },
                'target_achieved': { value: targetAchieved + '/' + results.length, label: 'ç›®æ¨™é”æˆæ•°' },
                'success_rate': { value: (results.filter(r => r.success).length / results.length * 100).toFixed(1) + '%', label: 'æˆåŠŸç‡' }
            });
        }

        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ: ä¸­è¦æ¨¡ã‚»ãƒƒãƒˆ
        function benchmarkMediumSets() {
            log("âš¡ ä¸­è¦æ¨¡ã‚»ãƒƒãƒˆï¼ˆ20-25ã‚»ãƒ«ï¼‰ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–‹å§‹", performanceResults, 'info');
            
            const results = [];
            for (let cellCount = 20; cellCount <= 25; cellCount++) {
                const cells = Array(cellCount).fill().map((_, i) => ({
                    row: Math.floor(i / 4),
                    col: i % 4
                }));

                const constraintGroup = {
                    cells: cells,
                    constraints: [
                        {
                            cells: cells.slice(0, 4),
                            count: 1
                        },
                        {
                            cells: cells.slice(2, 6),
                            count: 1
                        }
                    ]
                };

                // åˆ¶ç´„ã®ãƒ“ãƒƒãƒˆãƒãƒƒãƒ—ã‚’ç”Ÿæˆ
                for (const constraint of constraintGroup.constraints) {
                    const constraintCellsBits = new Uint32Array(bitCSP.intsNeeded);
                    bitCSP.bitSystem.coordsToBits(constraint.cells, constraintCellsBits);
                    constraint.cellsBits = constraintCellsBits;
                }

                const startTime = performance.now();
                const result = bitCSP.optimizeSmallSetSolvingBit(constraintGroup);
                const endTime = performance.now();

                results.push({
                    cellCount: cellCount,
                    executionTime: result.executionTime,
                    solutionCount: result.success ? result.solutionCount : 0,
                    success: result.success
                });

                log(`${cellCount}ã‚»ãƒ«: ${result.executionTime.toFixed(4)}ms (${result.success ? result.solutionCount + 'è§£' : 'å¤±æ•—'})`, 
                    performanceResults, result.success ? 'success' : 'warning');
            }

            // ä¸­è¦æ¨¡ã‚»ãƒƒãƒˆã®çµ±è¨ˆ
            const avgTime = results.filter(r => r.success).reduce((sum, r) => sum + r.executionTime, 0) / 
                           results.filter(r => r.success).length;
            
            log(`\nğŸ“Š ä¸­è¦æ¨¡ã‚»ãƒƒãƒˆçµ±è¨ˆ:`, performanceResults, 'info');
            log(`å¹³å‡å®Ÿè¡Œæ™‚é–“: ${avgTime.toFixed(4)}ms`, performanceResults);
            log(`æˆåŠŸç‡: ${results.filter(r => r.success).length}/${results.length} (${(results.filter(r => r.success).length/results.length*100).toFixed(1)}%)`, performanceResults);
        }

        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ: å¤§è¦æ¨¡ã‚»ãƒƒãƒˆ (18-20ã‚»ãƒ«)
        function benchmarkLargeSets() {
            log("âš¡ å¤§è¦æ¨¡ã‚»ãƒƒãƒˆï¼ˆ26-29ã‚»ãƒ«ï¼‰ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–‹å§‹", performanceResults, 'info');
            
            const results = [];
            for (let cellCount = 26; cellCount <= 29; cellCount++) {
                const cells = Array(cellCount).fill().map((_, i) => ({
                    row: Math.floor(i / 5),
                    col: i % 5
                }));

                const constraintGroup = {
                    cells: cells,
                    constraints: [
                        {
                            cells: cells.slice(0, 4),
                            count: 2
                        },
                        {
                            cells: cells.slice(3, 7),
                            count: 1
                        }
                    ]
                };

                // åˆ¶ç´„ã®ãƒ“ãƒƒãƒˆãƒãƒƒãƒ—ã‚’ç”Ÿæˆ
                for (const constraint of constraintGroup.constraints) {
                    const constraintCellsBits = new Uint32Array(bitCSP.intsNeeded);
                    bitCSP.bitSystem.coordsToBits(constraint.cells, constraintCellsBits);
                    constraint.cellsBits = constraintCellsBits;
                }

                const startTime = performance.now();
                const result = bitCSP.optimizeSmallSetSolvingBit(constraintGroup);
                const endTime = performance.now();

                results.push({
                    cellCount: cellCount,
                    executionTime: result.executionTime,
                    solutionCount: result.success ? result.solutionCount : 0,
                    success: result.success
                });

                log(`${cellCount}ã‚»ãƒ«: ${result.executionTime.toFixed(4)}ms (${result.success ? result.solutionCount + 'è§£' : 'å¤±æ•—'})`, 
                    performanceResults, result.success ? 'success' : 'warning');
            }

            // å¤§è¦æ¨¡ã‚»ãƒƒãƒˆã®çµ±è¨ˆ
            const avgTime = results.filter(r => r.success).reduce((sum, r) => sum + r.executionTime, 0) / 
                           results.filter(r => r.success).length;
            
            log(`\nğŸ“Š å¤§è¦æ¨¡ã‚»ãƒƒãƒˆçµ±è¨ˆ:`, performanceResults, 'info');
            log(`å¹³å‡å®Ÿè¡Œæ™‚é–“: ${avgTime ? avgTime.toFixed(4) : 'N/A'}ms`, performanceResults);
            log(`æˆåŠŸç‡: ${results.filter(r => r.success).length}/${results.length} (${(results.filter(r => r.success).length/results.length*100).toFixed(1)}%)`, performanceResults);
            
            // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è­¦å‘Š
            if (avgTime && avgTime > 100) {
                log(`âš ï¸ å¤§è¦æ¨¡ã‚»ãƒƒãƒˆã§ã¯100msä»¥ä¸Šã®å‡¦ç†æ™‚é–“ãŒç™ºç”Ÿã—ã¦ã„ã¾ã™`, performanceResults, 'warning');
            }
        }

        // æ¥µé™ãƒ†ã‚¹ãƒˆ: 29ã‚»ãƒ«5å„„ãƒ‘ã‚¿ãƒ¼ãƒ³ (64x64ç›¤é¢ã®é™ç•Œæ€§èƒ½ç¢ºèª)
        function benchmarkExtremeTest() {
            log("ğŸ”¥ æ¥µé™ãƒ†ã‚¹ãƒˆ: 29ã‚»ãƒ« 5å„„ãƒ‘ã‚¿ãƒ¼ãƒ³å‡¦ç†é–‹å§‹", performanceResults, 'info');
            log("âš ï¸ æ³¨æ„: ã“ã®å‡¦ç†ã«ã¯æ•°ç§’ã€œæ•°åç§’ã‹ã‹ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™", performanceResults, 'warning');
            
            const cells29 = Array(29).fill().map((_, i) => ({
                row: Math.floor(i / 6),
                col: i % 6
            }));

            const constraintGroup = {
                cells: cells29,
                constraints: [
                    {
                        cells: cells29.slice(0, 6),
                        count: 3
                    },
                    {
                        cells: cells29.slice(5, 11),
                        count: 2
                    },
                    {
                        cells: cells29.slice(10, 16),
                        count: 2
                    }
                ]
            };

            // åˆ¶ç´„ã®ãƒ“ãƒƒãƒˆãƒãƒƒãƒ—ã‚’ç”Ÿæˆ
            for (const constraint of constraintGroup.constraints) {
                const constraintCellsBits = new Uint32Array(bitCSP.intsNeeded);
                bitCSP.bitSystem.coordsToBits(constraint.cells, constraintCellsBits);
                constraint.cellsBits = constraintCellsBits;
            }

            log("ğŸš€ 29ã‚»ãƒ«å‡¦ç†é–‹å§‹...", performanceResults, 'info');
            const extremeStartTime = performance.now();
            const result = bitCSP.optimizeSmallSetSolvingBit(constraintGroup);
            const extremeEndTime = performance.now();

            const totalTime = extremeEndTime - extremeStartTime;
            
            if (result.success) {
                log(`âœ… 29ã‚»ãƒ«æ¥µé™ãƒ†ã‚¹ãƒˆæˆåŠŸï¼`, performanceResults, 'success');
                log(`   - ç·å®Ÿè¡Œæ™‚é–“: ${totalTime.toFixed(2)}ms`, performanceResults, 'success');
                log(`   - è§£æ±ºãƒ‘ã‚¿ãƒ¼ãƒ³æ•°: ${result.solutionCount.toLocaleString()}`, performanceResults);
                log(`   - ã‚»ãƒ«ç¢ºç‡è¨ˆç®—å®Œäº†: ${Object.keys(result.cellProbabilities).length}ã‚»ãƒ«`, performanceResults);
                log(`   - å¹³å‡å‡¦ç†æ™‚é–“/è§£: ${result.averageTimePerSolution.toFixed(6)}ms`, performanceResults);
                
                // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è©•ä¾¡
                if (totalTime < 1000) {
                    log(`ğŸ† å„ªç§€: 1ç§’ä»¥å†…ã§ã®29ã‚»ãƒ«å‡¦ç†é”æˆï¼`, performanceResults, 'success');
                } else if (totalTime < 5000) {
                    log(`ğŸ¯ è‰¯å¥½: 5ç§’ä»¥å†…ã§ã®29ã‚»ãƒ«å‡¦ç†é”æˆ`, performanceResults, 'success');
                } else if (totalTime < 30000) {
                    log(`âš ï¸ å®Ÿç”¨ç¯„å›²: 30ç§’ä»¥å†…ã§ã®å‡¦ç†å®Œäº†`, performanceResults, 'warning');
                } else {
                    log(`ğŸš¨ é‡ã„å‡¦ç†: 30ç§’è¶…ã®å‡¦ç†æ™‚é–“`, performanceResults, 'warning');
                }

                // 64x64ç›¤é¢ã§ã®å®Ÿç”¨æ€§è©•ä¾¡
                log(`\nğŸ“Š 64x64ç›¤é¢å®Ÿç”¨æ€§è©•ä¾¡:`, performanceResults, 'info');
                if (totalTime < 100) {
                    log(`  ğŸ¯ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å‡¦ç†å¯èƒ½ (<100ms)`, performanceResults, 'success');
                } else if (totalTime < 1000) {
                    log(`  âœ… å¿«é©ãªå‡¦ç†é€Ÿåº¦ (<1ç§’)`, performanceResults, 'success');
                } else {
                    log(`  âš ï¸ é‡ã„å‡¦ç† - Phase3-4ã®å¤§è¦æ¨¡æœ€é©åŒ–ãŒå¿…è¦`, performanceResults, 'warning');
                }
                
            } else {
                log(`âŒ 29ã‚»ãƒ«æ¥µé™ãƒ†ã‚¹ãƒˆå¤±æ•—: ${result.reason}`, performanceResults, 'error');
            }

            updatePerformanceMetrics({
                'extreme_time': { value: totalTime.toFixed(2) + 'ms', label: '29ã‚»ãƒ«å‡¦ç†æ™‚é–“' },
                'extreme_solutions': { value: result.success ? result.solutionCount.toLocaleString() : '0', label: 'è§£æ±ºãƒ‘ã‚¿ãƒ¼ãƒ³æ•°' },
                'cells_processed': { value: '29', label: 'å‡¦ç†ã‚»ãƒ«æ•°' },
                'patterns_processed': { value: '536,870,912', label: 'å…¨ãƒ‘ã‚¿ãƒ¼ãƒ³æ•°' }
            });
        }

        // Phase2æ¯”è¼ƒãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯
        function benchmarkComparisonTest() {
            log("ğŸ“Š Phase2æ¯”è¼ƒãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–‹å§‹", performanceResults, 'info');
            
            // åŒä¸€æ¡ä»¶ã§ã®ãƒ†ã‚¹ãƒˆï¼ˆ5ã‚»ãƒ«ã€2åˆ¶ç´„ï¼‰
            const testGroup = {
                cells: [
                    {row: 1, col: 1}, {row: 1, col: 2}, {row: 1, col: 3},
                    {row: 2, col: 1}, {row: 2, col: 2}
                ],
                constraints: [
                    {
                        cells: [{row: 1, col: 1}, {row: 1, col: 2}, {row: 2, col: 1}],
                        count: 1
                    },
                    {
                        cells: [{row: 1, col: 2}, {row: 1, col: 3}, {row: 2, col: 2}],
                        count: 1
                    }
                ]
            };

            // åˆ¶ç´„ã®ãƒ“ãƒƒãƒˆãƒãƒƒãƒ—ã‚’ç”Ÿæˆ
            for (const constraint of testGroup.constraints) {
                const constraintCellsBits = new Uint32Array(bitCSP.intsNeeded);
                bitCSP.bitSystem.coordsToBits(constraint.cells, constraintCellsBits);
                constraint.cellsBits = constraintCellsBits;
            }

            // 100å›å®Ÿè¡Œã—ã¦ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’æ¸¬å®š
            const iterations = 100;
            let totalTime = 0;
            let successCount = 0;

            for (let i = 0; i < iterations; i++) {
                const result = bitCSP.optimizeSmallSetSolvingBit(testGroup);
                if (result.success) {
                    totalTime += result.executionTime;
                    successCount++;
                }
            }

            const avgTime = totalTime / successCount;
            log(`100å›å®Ÿè¡Œå¹³å‡æ™‚é–“: ${avgTime.toFixed(4)}ms`, performanceResults, 'success');
            log(`æˆåŠŸç‡: ${successCount}/${iterations} (${(successCount/iterations*100).toFixed(1)}%)`, performanceResults, 'success');
            
            // Phase2ã®1.70ms/3ã‚°ãƒ«ãƒ¼ãƒ—ã¨æ¯”è¼ƒ
            const phase2Reference = 1.70 / 3; // ç´„0.567ms per group
            const improvement = ((phase2Reference - avgTime) / phase2Reference * 100);
            
            if (avgTime < phase2Reference) {
                log(`ğŸš€ Phase2æ¯”: ${improvement.toFixed(1)}% é«˜é€ŸåŒ–é”æˆï¼`, performanceResults, 'success');
            } else {
                log(`âš ï¸ Phase2æ¯”: ${(-improvement).toFixed(1)}% ä½ä¸‹`, performanceResults, 'warning');
            }
        }

        // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¡¨ç¤º
        function updatePerformanceMetrics(metrics) {
            performanceMetrics.innerHTML = '';
            for (const [key, data] of Object.entries(metrics)) {
                const card = document.createElement('div');
                card.className = 'metric-card';
                card.innerHTML = `
                    <div class="metric-value">${data.value}</div>
                    <div class="metric-label">${data.label}</div>
                `;
                performanceMetrics.appendChild(card);
            }
        }

        // è©³ç´°ãƒ†ã‚¹ãƒˆé–¢æ•°ç¾¤
        function testComplexConstraints() {
            log("ğŸ” è¤‡é›‘åˆ¶ç´„ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ†ã‚¹ãƒˆé–‹å§‹", detailedResults, 'info');
            // å®Ÿè£…äºˆå®š: è¤‡æ•°åˆ¶ç´„ã®ç›¸äº’ä½œç”¨ãƒ†ã‚¹ãƒˆ
            log("å®Ÿè£…äºˆå®š: è¤‡æ•°åˆ¶ç´„ã®ç›¸äº’ä½œç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ†ã‚¹ãƒˆ", detailedResults, 'warning');
        }

        function testEdgeCases() {
            log("ğŸ” ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹", detailedResults, 'info');
            // å®Ÿè£…äºˆå®š: å¢ƒç•Œæ¡ä»¶ã€ç•°å¸¸ç³»ã®ãƒ†ã‚¹ãƒˆ
            log("å®Ÿè£…äºˆå®š: å¢ƒç•Œæ¡ä»¶ãƒ»ç•°å¸¸ç³»ã®ãƒ†ã‚¹ãƒˆ", detailedResults, 'warning');
        }

        function testMemoryEfficiency() {
            log("ğŸ” ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ãƒ†ã‚¹ãƒˆé–‹å§‹", detailedResults, 'info');
            // å®Ÿè£…äºˆå®š: ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®æ¸¬å®šã¨åˆ†æ
            log("å®Ÿè£…äºˆå®š: ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®æ¸¬å®šã¨åˆ†æ", detailedResults, 'warning');
        }

        // åˆæœŸåŒ–
        log("ğŸš€ Phase3-1ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†", testResults, 'success');
        log("Phase2ã®1.70ms/3ã‚°ãƒ«ãƒ¼ãƒ—å®Ÿç¸¾ã‚’ä¸Šå›ã‚‹è¶…é«˜é€ŸåŒ–ã‚’ç›®æŒ‡ã—ã¾ã™ï¼", testResults, 'info');
    </script>
</body>
</html>